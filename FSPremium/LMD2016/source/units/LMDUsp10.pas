unit LMDUsp10;
{$I lmdcmps.inc}

{###############################################################################

LMD VCL Series 2016
© by LMD Innovative
-------------------

For support or information contact us at:

email              : mail@lmdsupport.com
WWW                : http://www.lmdinnovative.com
SupportSite        : http://www.lmdsupport.com
Wiki               : http://wiki.lmd.de
Fax                : ++49 6131 4984372

This code is for reference purposes only and may not be copied
or distributed in any format electronic or otherwise except one
copy for backup purposes.

No Component Kit or Component individually or in a collection,
subclassed or otherwise from the code in this unit, or associated
.pas, .dfm, .dcu, .ocx, .dll or ActiveX files may be sold or
distributed without express permission from LMD Innovative.

For further license information please refer to the associated
license html file in \info folder.

################################################################################

LMDUsp10 unit
-------------


Changes
-------
Release 6.0 (February 2007)
 - Initial Release

###############################################################################}
interface

uses
  Windows ;

const
  usp10 = 'usp10.dll'; // Setup as you need
//   Copyright (c) Microsoft Corporation. All rights reserved.
  USPBUILD = 0400;
  SCRIPT_UNDEFINED = 0;
  USP_E_SCRIPT_NOT_IN_FONT = HRESULT($80040200); // Script doesn't exist in font

type

  PSCRIPT_CACHE = Pointer;
  TScriptCache = PSCRIPT_CACHE;
  PScriptCache = ^TScriptCache;

function ScriptFreeCache(psc: PScriptCache): HRESULT; external usp10 name 'ScriptFreeCache';

const
  scContextDigits = $10000;      // Means use previous script instead of uDefaultLanguage
  scInvertPreBoundDir = $20000;  // The following flags provide legacy support for GetCharacterPlacement features
  scInvertPostBoundDir = $40000; // Reading order of virtual item immediately prior to string
  scLinkStringBefore = $80000;   // Reading order of virtual item immediately following string
  scLinkStringAfter = $100000;   // Equivalent to presence of ZWJ before string
  scNeutralOverride = $200000;   // Equivalent to presence of ZWJ after string
  scNumericOverride = $400000;   // Causes all neutrals to be strong in the current embedding direction
  scLegacyBidiClass = $800000;   // Causes all numerals to be strong in the current embedding direction

type
  PSCRIPT_CONTROL = ^SCRIPT_CONTROL;
  SCRIPT_CONTROL = record
    uDefaultLanguage: WORD;
    fFlags: Byte;
    fReserved: Byte;
  end;
  tag_SCRIPT_CONTROL = SCRIPT_CONTROL;
  TScriptControl = SCRIPT_CONTROL;
  PScriptControl = ^TScriptControl;

const
  ssBidiLevel = $1F;          { Unicode Bidi algorithm embedding level (0-16) }
  ssOverrideDirection = $20;  { Set when in LRO/RLO embedding }
  ssInhibitSymSwap = $40;     { Set by U+206A (ISS), cleared by U+206B (ASS) }
  ssCharShape = $80;          { Set by U+206D (AAFS), cleared by U+206C (IAFS) }
  ssDigitSubstitute = $100;   { Set by U+206E (NADS), cleared by U+206F (NODS) }
  ssInhibitLigate = $200;     { Equiv !GCP_Ligate, no Unicode control chars yet }
  ssDisplayZWG = $400;        { Equiv GCP_DisplayZWG, no Unicode control characters yet }
  ssArabicNumContext = $800;  { For EN->AN Unicode rule }
  ssGcpClusters = $1000;      { For Generating Backward Compatible GCP Clusters (legacy Apps) }
  ssReserved = $2000;         { For use by shaping engine }
  ssEngineReserved = $C000;

type
  SCRIPT_STATE = type Word;
  PSCRIPT_STATE = ^SCRIPT_STATE;
  tag_SCRIPT_STATE = SCRIPT_STATE;
  TScriptState = SCRIPT_STATE;
  PScriptState = ^TScriptState;
  const
  saScript = $3FF;        { Shaping engine }
  saRTL = $400;           { Rendering direction }
  saLayoutRTL = $800;     { Set for GCP classes ARABIC/HEBREW and LOCALNUMBER }
  saLinkBefore = $1000;   { Implies there was a ZWJ before this item }
  saLinkAfter = $2000;    { Implies there is a ZWJ following this item. }
  saLogicalOrder = $4000; { Set by client as input to ScriptShape/Place }
  saNoGlyphIndex = $8000; { Generated by ScriptShape/Place - this item does not use glyph indices }

type
  SCRIPT_ANALYSIS = record
    Flags: word;
    S: SCRIPT_STATE;
  end;
  PSCRIPT_ANALYSIS = ^SCRIPT_ANALYSIS;
  tag_SCRIPT_ANALYSIS = SCRIPT_ANALYSIS;
  TScriptAnalysis = SCRIPT_ANALYSIS;
  PScriptAnalysis = ^TScriptAnalysis;
  type
  PSCRIPT_ITEM = ^SCRIPT_ITEM;
  SCRIPT_ITEM = record
    iCharPos: LongInt;
    a: SCRIPT_ANALYSIS;
  end;
  tag_SCRIPT_ITEM = SCRIPT_ITEM;
  TScriptItem = SCRIPT_ITEM;
  PScriptItem = ^TScriptItem;
  function ScriptItemize(const pwcInChars: PWCHAR;
                       cInChars: longint;
                       cMaxItems: longint;
                       const psControl: PSCRIPT_CONTROL;
                       const psState: PSCRIPT_STATE;
                       pItems: PScriptItem;
                       pcItems: PInteger): HRESULT; stdcall; external usp10 name 'ScriptItemize';

function ScriptLayout(cRuns: longint;
                      const pbLevel: PBYTE;
                      piVisualToLogical: PInteger;
                      piLogicalToVisual: PInteger): HRESULT; stdcall; external usp10 name 'ScriptLayout'; // Out  List of visual run positions

type
  SCRIPT_JUSTIFY = (
    SCRIPT_JUSTIFY_NONE,           { Justification can't be applied at this glyph }
    SCRIPT_JUSTIFY_ARABIC_BLANK,   { This glyph represents a blank in an Arabic run }
    SCRIPT_JUSTIFY_CHARACTER,      { Inter-character justification point follows this glyph }
    SCRIPT_JUSTIFY_RESERVED1,      { Reserved #1 }
    SCRIPT_JUSTIFY_BLANK,          { This glyph represents a blank outside an Arabic run }
    SCRIPT_JUSTIFY_RESERVED2,      { Reserved #2 }
    SCRIPT_JUSTIFY_RESERVED3,      { Reserved #3 }
    SCRIPT_JUSTIFY_ARABIC_NORMAL,  { Normal Middle-Of-Word glyph that connects to the right (begin) }
    SCRIPT_JUSTIFY_ARABIC_KASHIDA, { Kashida(U+640) in middle of word }
    SCRIPT_JUSTIFY_ARABIC_ALEF,    { Final form of Alef-like (U+627, U+625, U+623, U+632) }
    SCRIPT_JUSTIFY_ARABIC_HA,      { Final form of Ha (U+647) }
    SCRIPT_JUSTIFY_ARABIC_RA,      { Final form of Ra (U+631) }
    SCRIPT_JUSTIFY_ARABIC_BA,      { Middle-Of-Word form of Ba (U+628) }
    SCRIPT_JUSTIFY_ARABIC_BARA,    { Ligature of alike (U+628,U+631) }
    SCRIPT_JUSTIFY_ARABIC_SEEN,    { Highest priority: Initial shape of Seen(U+633) (end) }
    SCRIPT_JUSTIFY_RESERVED4       { Reserved #4 }
  );
  tag_SCRIPT_JUSTIFY = SCRIPT_JUSTIFY;

const
  svJustification = $F;    { Justification class }
  svClusterStart = $10;    { First glyph of representation of cluster }
  svDiacritic = $20;       { Diacritic }
  svZeroWidth = $40;       { Blank, ZWJ, ZWNJ etc, with no width }
  svReserved = $80;        { General reserved }

type

  PSCRIPT_VISATTR = ^SCRIPT_VISATTR;

  SCRIPT_VISATTR = record
    fFlags: Byte;
    fShapeReserved: Byte;
  end;
  tag_SCRIPT_VISATTR = SCRIPT_VISATTR;
  TScriptVisattr = SCRIPT_VISATTR;

  PScriptVisattr = ^TScriptVisattr;

function ScriptShape(hdc: HDC;
                     psc: PScriptCache;
                     const pwcChars: PWideChar;
                     cChars: longint;
                     cMaxGlyphs: longint;
                     psa: PSCRIPT_ANALYSIS;
                     pwOutGlyphs: PWORD;
                     pwLogClust: PWORD;
                     psva: PScriptVisattr;
                     pcGlyphs: PInteger): HRESULT; stdcall; external usp10 name 'ScriptShape';

{$ifndef LSDEFS_DEFINED}

type
  PGOFFSET = ^GOFFSET;
  GOFFSET = record
    du: LongInt;
    dv: LongInt;
  end;
  TGOffset = GOFFSET;
{$endif}

function ScriptPlace(hdc: HDC;                    { In    Optional (see under caching) }
                     psc: PScriptCache;           { InOut Cache handle }
                     const pwGlyphs: PWORD;       { In    Glyph buffer from prior ScriptShape call }
                     cGlyphs: longint;            { In    Number of glyphs }
                     const psva: PScriptVisattr;  { In    Visual glyph attributes }
                     psa: PSCRIPT_ANALYSIS;       { InOut Result of ScriptItemize (may have fNoGlyphIndex set) }
                     piAdvance: PInteger;         { Out   Advance wdiths }
                     pGoffset: PGOFFSET;          { Out   x,y offset for combining glyph }
                     pABC: PABC): HRESULT;        { Out   Composite ABC for the whole run (Optional) }
                     stdcall; external usp10 name 'ScriptPlace';

function ScriptTextOut(const hdc: HDC;              { In     OS handle to device context (required) }
                       psc: PScriptCache;           { InOut  Cache handle }
                       x: longint;                  { In     x,y position for first glyph }
                       y: longint;                  { In }
                       fuOptions: UINT;             { In     ExtTextOut options }
                       const lprc: PRECT;           { In     optional clipping/opaquing rectangle }
                       const psa: PSCRIPT_ANALYSIS; { In     Result of ScriptItemize }
                       const pwcReserved: PWCHAR;   { In     Reserved (requires NULL) }
                       iReserved: longint;          { In     Reserved (requires 0) }
                       const pwGlyphs: PWORD;       { In     Glyph buffer from prior ScriptShape call }
                       cGlyphs: longint;            { In     Number of glyphs }
                       const piAdvance: PInteger;   { In     Advance widths from ScriptPlace }
                       const piJustify: PInteger;   { In     Justified advance widths (optional) }
                       const pGoffset: PGOFFSET): HRESULT; { In     x,y offset for combining glyph }
                       stdcall; external usp10 name 'ScriptTextOut';

function ScriptJustify(const psva: PSCRIPT_VISATTR;   { In   Collected visual attributes for entire line }
                       const piAdvance: PInteger;     { In   Advance widths from ScriptPlace }
                       cGlyphs: longint;              { In   Size of all arrays }
                       iDx: longint;                  { In   Desired width change, either increase or descrease }
                       iMinKashida: longint;          { In   Minimum length of continuous kashida glyph to generate }
                       piJustify: PInteger): HRESULT; { Out  Updated advance widths to pass to ScriptTextOut }
                       stdcall; external usp10 name 'ScriptJustify';

type
  TScriptLogAttrs = (
    fSoftBreak,
    fWhiteSpace,
    fCharStop,
    fWordStop,
    fInvalid,
    fRes1,
    fRes2,
    fRes3
  );

  PSCRIPT_LOGATTR = ^SCRIPT_LOGATTR;
  SCRIPT_LOGATTR = set of TScriptLogAttrs;
  tag_SCRIPT_LOGATTR = SCRIPT_LOGATTR;
  TScriptLogAttr = SCRIPT_LOGATTR;
  PScriptLogAttr = ^TScriptLogAttr;

function ScriptBreak(const pwcChars: PWCHAR;
                     cChars: longint;
                     const psa: PSCRIPT_ANALYSIS;
                     psla: PScriptLogAttr): HRESULT; stdcall; external usp10 name 'ScriptBreak';

function ScriptCPtoX(iCP: longint;
                     fTrailing: BOOL;
                     cChars: longint;
                     cGlyphs: longint;
                     pwLogClust: PWORD;
                     psva: PSCRIPT_VISATTR;
                     piAdvance: PInteger;
                     psa: PSCRIPT_ANALYSIS;
                     piX: PInteger): HRESULT; stdcall; external usp10 name 'ScriptCPtoX';

function ScriptXtoCP(iX: longint;
                     cChars: longint;
                     cGlyphs: longint;
                     pwLogClust: PWORD;
                     psva: PSCRIPT_VISATTR;
                     piAdvance: PInteger;
                     psa: PSCRIPT_ANALYSIS;
                     piCP: PInteger;
                     piTrailing: PInteger): HRESULT; stdcall; external usp10 name 'ScriptXtoCP';

function ScriptGetLogicalWidths(psa: PSCRIPT_ANALYSIS;
                                cChars: longint;
                                cGlyphs: longint;
                                piGlyphWidth: PInteger;
                                pwLogClust: PWORD;
                                psva: PScriptVisAttr;
                                piDx: PInteger): HRESULT; stdcall; external usp10 name 'ScriptGetLogicalWidths';

function ScriptApplyLogicalWidth(piDx: PInteger;
                                 cChars: longint;
                                 cGlyphs: longint;
                                 pwLogClust: PWORD;
                                 psva: PSCRIPT_VISATTR;
                                 piAdvance: PInteger;
                                 psa: PSCRIPT_ANALYSIS;
                                 pABC: PABC;
                                 piJustify:PInteger): HRESULT; stdcall; external usp10 name 'ScriptApplyLogicalWidth';

const
  SGCM_RTL = $00000001;

function ScriptGetCMap(hdc:HDC; psc: PScriptCache; pwcInChars:PWCHAR; cChars:longint; dwFlags:DWORD;
           pwOutGlyphs:PWORD):HRESULT; stdcall; external usp10 name 'ScriptGetCMap';

function ScriptGetGlyphABCWidth(hdc: HDC; psc: PScriptCache; wGlyph: WORD; pABC: PABC): HRESULT; stdcall; external usp10 name 'ScriptGetGlyphABCWidth';

const
  sp1Numeric = $10000;
  sp1Complex = $20000;
  sp1NeedsWordBreaking = $40000;
  sp1NeedsCaretInfo = $80000;
  sp1CharSet = $FF00000;
  sp1Control = $10000000;
  sp1PrivateUseArea = $20000000;
  sp1NeedsCharacterJustify = $40000000;
  sp1InvalidGlyph = $80000000;

  sp2InvalidLogAttr = $1;
  sp2CDM = $2;
  sp2AmbiguousCharSet = $4;
  sp2ClusterSizeVaries = $8;
  sp2RejectInvalid = $10;

type
  PPSCRIPT_PROPERTIES = ^PSCRIPT_PROPERTIES;
  PSCRIPT_PROPERTIES = ^SCRIPT_PROPERTIES;
  SCRIPT_PROPERTIES = record
    LangId: Word;
    flag1: Word;
    flag2: Word;
  end;
  function ScriptGetProperties(var ppSp: PPSCRIPT_PROPERTIES;
                             piNumScripts: PInteger): HRESULT; stdcall; external usp10 name 'ScriptGetProperties';

type
  PSCRIPT_FONTPROPERTIES = ^SCRIPT_FONTPROPERTIES;
  SCRIPT_FONTPROPERTIES = record
    cBytes : longint;
    wgBlank : WORD;
    wgDefault : WORD;
    wgInvalid : WORD;
    wgKashida : WORD;
    iKashidaWidth : longint;
  end;
  TScriptFontproperties = SCRIPT_FONTPROPERTIES;
  PScriptFontproperties = ^TScriptFontproperties;

function ScriptGetFontProperties(hdc: HDC; psc: PScriptCache; sfp: PScriptFontproperties): HRESULT; stdcall; external usp10 name 'ScriptGetFontProperties';

function ScriptCacheGetHeight(hdc: HDC; psc: PScriptCache; tmHeight: PInteger): HRESULT; stdcall; external usp10 name 'ScriptCacheGetHeight';

const
  SSA_PASSWORD = $00000001;
{ Expand tabs }
  SSA_TAB = $00000002;
{ Clip string at iReqWidth }
  SSA_CLIP = $00000004;
{ Justify string to iReqWidth }
  SSA_FIT = $00000008;
{ Provide representation glyphs for control characters }
  SSA_DZWG = $00000010;
{ Use fallback fonts }
  SSA_FALLBACK = $00000020;
{ Return break flags (character and word stops) }
  SSA_BREAK = $00000040;
{ Generate glyphs, positions and attributes }
  SSA_GLYPHS = $00000080;
{ Base embedding level 1 }
  SSA_RTL = $00000100;
{ Return missing glyphs and LogCLust with GetCharacterPlacement conventions }
  SSA_GCP = $00000200;
{ Replace '&' with underline on subsequent codepoint }
  SSA_HOTKEY = $00000400;
{ Write items with ExtTextOutW Unicode calls, not glyphs }
  SSA_METAFILE = $00000800;
{ Apply FE font linking/association to non-complex text }
  SSA_LINK = $00001000;
{ Remove first '&' from displayed string }
  SSA_HIDEHOTKEY = $00002000;
{ Display underline only. }
  SSA_HOTKEYONLY = $00002400;
{ Internal - calculate full width and out the number of chars can fit in iReqWidth. }
  SSA_FULLMEASURE = $04000000;
{ Internal - enable FallBack for all LPK Ansi calls Except BiDi hDC calls }
  SSA_LPKANSIFALLBACK = $08000000;
{ Internal }
  SSA_PIDX = $10000000;
{ Internal - Used when DC is mirrored }
  SSA_LAYOUTRTL = $20000000;
{ Internal - Used only by GDI during metafiling - Use ExtTextOutA for positioning }
  SSA_DONTGLYPH = $40000000;
{ Internal - Used by GCP to justify the non Arabic glyphs only. }
  SSA_NOKASHIDA = $80000000;

type
  PSCRIPT_TABDEF = ^SCRIPT_TABDEF;
  SCRIPT_TABDEF = record
    cTabStops : longint;
    iScale : longint;
    pTabStops : PInteger;
    iTabOrigin : longint;
  end;
  tag_SCRIPT_TABDEF = SCRIPT_TABDEF;
  TScriptTabDef = SCRIPT_TABDEF;
  PScriptTabDef = ^TScriptTabDef;

  SCRIPT_STRING_ANALYSIS = pointer;
  TScriptStringAnalysis = SCRIPT_STRING_ANALYSIS;
  PScriptStringAnalysis = ^TScriptStringAnalysis;
  function ScriptStringAnalyse(hdc: HDC;
                             const pString: PWCHAR;
                             cString: Integer;
                             cGlyphs: Integer;
                             iCharset:Integer;
                             dwFlags: DWORD;
                             iReqWidth: Integer;
                             psControl: PScriptControl;
                             psState: PScriptState;
                             const piDx: PInteger;
                             pTabdef: PScriptTabDef;
                             const pbInClass: PBYTE;
                             pssa: PScriptStringAnalysis): HRESULT; stdcall; external usp10 name 'ScriptStringAnalyse';

function ScriptStringFree(pssa: SCRIPT_STRING_ANALYSIS):HRESULT; stdcall; external usp10 name 'ScriptStringFree';

function ScriptString_pSize(ssa: SCRIPT_STRING_ANALYSIS): PSize; stdcall; external usp10 name 'ScriptString_pSize';

function ScriptString_pcOutChars(ssa: SCRIPT_STRING_ANALYSIS): PInteger; stdcall; external usp10 name 'ScriptString_pcOutChars';

function ScriptString_pLogAttr(ssa: SCRIPT_STRING_ANALYSIS): PSCRIPT_LOGATTR; stdcall; external usp10 name 'ScriptString_pLogAttr';

function ScriptStringGetOrder(ssa: SCRIPT_STRING_ANALYSIS; puOrder:PUINT):HRESULT;stdcall; external usp10 name 'ScriptStringGetOrder';

function ScriptStringCPtoX(ssa: SCRIPT_STRING_ANALYSIS; icp:longint; fTrailing:BOOL; pX:PInteger):HRESULT; stdcall; external usp10 name 'ScriptStringCPtoX';

function ScriptStringXtoCP(ssa: SCRIPT_STRING_ANALYSIS; iX:longint; piCh:PInteger; piTrailing:PInteger):HRESULT; stdcall; external usp10 name 'ScriptStringXtoCP';

function ScriptStringGetLogicalWidths(ssa: SCRIPT_STRING_ANALYSIS; piDx:PInteger): HRESULT; stdcall; external usp10 name 'ScriptStringGetLogicalWidths';

function ScriptStringValidate(ssa: SCRIPT_STRING_ANALYSIS):HRESULT; stdcall; external usp10 name 'ScriptStringValidate';

function ScriptStringOut(ssa: TScriptStringAnalysis;
                         iX: Integer;
                         iY: Integer;
                         uOptions: LongWord;
                         const prc: PRect;
                         iMinSel: Integer;
                         iMaxSel: Integer;
                         fDisabled: BOOL): HRESULT; stdcall; external usp10 name 'ScriptStringOut';

const
  SIC_COMPLEX = 1;
{ Treat digits U+0030 through U+0039 as complex }
  SIC_ASCIIDIGIT = 2;
{ Treat neutrals as complex }
  SIC_NEUTRAL = 4;

function ScriptIsComplex(pwcInChars: PWCHAR; cInChars:longint; dwFlags:DWORD):HRESULT; stdcall; external usp10 name 'ScriptIsComplex';

const
  sdNationalDigitLanguage = $FFFF;
  sdTraditionalDigitLanguage = $FFFF0000;
  sdDigitSubstitute = $FF;

type
  PSCRIPT_DIGITSUBSTITUTE = ^SCRIPT_DIGITSUBSTITUTE;
  SCRIPT_DIGITSUBSTITUTE = record
    flag0 : longint;
    flag1 : word;
    dwReserved : DWORD;
  end;
  tag_SCRIPT_DIGITSUBSTITUTE = SCRIPT_DIGITSUBSTITUTE;

function ScriptRecordDigitSubstitution(Locale:LCID; psds:PSCRIPT_DIGITSUBSTITUTE):HRESULT; stdcall; external usp10 name 'ScriptRecordDigitSubstitution';

const
  SCRIPT_DIGITSUBSTITUTE_CONTEXT = 0;
{ No substitution }
  SCRIPT_DIGITSUBSTITUTE_NONE = 1;
{ Substitute with official national digits }
  SCRIPT_DIGITSUBSTITUTE_NATIONAL = 2;
{ Substitute with traditional digits of the locale }
  SCRIPT_DIGITSUBSTITUTE_TRADITIONAL = 3;

function ScriptApplyDigitSubstitution(psds:PSCRIPT_DIGITSUBSTITUTE; psc:PSCRIPT_CONTROL; pss:PSCRIPT_STATE):HRESULT; stdcall; external usp10 name 'ScriptApplyDigitSubstitution';

implementation

end.
