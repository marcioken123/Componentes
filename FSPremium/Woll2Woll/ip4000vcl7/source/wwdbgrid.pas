unit Wwdbgrid;
{
//
// Components : TwwDBGrid
//
// Copyright (c) 1995-2001 by Woll2Woll Software
//
// 7/19/97 - Only readjust customedit rectangle if cell boundary left,right
//           has changed.  Previoulsy would readjust even on height change
//           which caused a flicker with a lookupcombo that had its icon too
//           big to fit into the cell.
// 8/12/97 - Optimization for screen painting.  Check if field is TBlobField
//           before calling IsRichEditCell
// 8/14/97 - Optimized logic to speed painting of grid in
//           function IsRichEditCell and IsCustomEditCell
// 9/2/97  - Override isCustomEditCell so that it ignores record-view when
//           mapping
// 9/4/97  - fctRichEdit same path as customEdit in SetControlType method
// 9/15/97 - Hidecontrols needed to be changed to HideControls.
// 9/19/97 - Allow multi-selection checkbox to be toggled even when editing is
//           not allowed
// 10/24/97- Only toggle checkboxes if can edit grid or multi-selection checkbox
// 12/02/97- Added try block on gotobookmark to catch exception when bkmrk2 is invalid
//
// 1/9/98  - Only set focus if canFocus is true
// 1/25/98 - Add EditControlOptions | DisableCustomControls so record-panel
//           and grid will not both be using the same edit control.
// 1/28/97 - Allow Change of text when there is a protected flag in richtext to handle
//           TRichEdit bug.
// 3/11/98 - Auto-invalidate if grid rowcount or colcount changes
// 3/20/98 - Prevent flicker when control becomes visible by only calling update
//           for control
// 3/20/98 - Rely on edit control to selectAll when control is made visible
//           with dgAlwaysShowEditor as True
// 4/9/98 -  Clear currentcustomedit when table is made active
// 5/13/98 - Fix memory leak for ShiftSelectBookmark
// 8/13/98 - Fix for datetimepicker disabling bug
// 10/6/98 - Support display of simple text even when field is defined as a rich
//           edit text.
// 10/27/98 -Update MouseCoord method to support bdRightToLeft - Delphi's
//           version does not support fixed columns.
// 11/26/98 - Respect readonly property of related field for default datetimepicker
// 12/7/98 - Correct OnColWidthChanged event passing the wrong column
// 1/26/99 - Prevent clearing of grid when hiding controls
// 2/19/99 - Default datetimepicker should go through default datetimepicker
//           specfic code when changing columns.  Fixes Readonly problem for
//           default datetimepicker
// 3/17/99 - Fire OnMultiSelectRecord with ShiftSelect
// 6/28/99 - Fire OnKeyPress event even when rowselect/edit=false on custom control field
// 9/30/99 - Handle INI file issues with datamodule and FormCreate. (PYW)
// 2/19/00 - Create RefreshActiveControl method to call from ApplySelected
//           This removes the dependency upon the column changing for the control
//           information to be updated.
// 3/6/00 - Add new fields to dynamic selected property from selected property generated by iniattributes
// 3/9/00 - OnColEnter being fired twice
// 4/24/00 - Don't toggle checkbox when dataset is readonly
// 5/4/00 - publish OnStartDrag property
// 8/11/00 - Make LoadFromIniFile and SaveToIniFile virtual
// 4/12/01 - Don't load from ini when design-time
// 4/12/01 - Added Grid exporting capability.
// 8/22/01 - Don't set focus if active form is not for this grid
//           For instance, in case there was validation in the tfield.onvalidate event
//           which showed a message
// 9/26/01 - Added new event to allow formating of SYLK data export when exporting to a file. -PYW
// 10/28/01 - Otherwise mapped values not respected
// 12/11/01 - RSW - Don't pass to inherited KeyDown as then focus can get lost causing datetimepicker to not dropdown
// 1/9/2002 - Added patch[5] for backwards compatibility when exiting the grid error messages from onvalidate were not
//            displayed. Using a Patch variable to provide solution while studying impact.
// 3/14/2002- PYW - Only SelectRecord/UnSelectRecord if multiselect and RowSelect enabled and space is pressed.
//            Otherwise space on a checkbox will not be respected thus breaking backwards compatibility.
// 4/16/2002 - If an exception is raised in HideControls when a customedit loses focus and the grid gets it.
// 5/8/2002 - PYW - Corrected some TCustomGrid ColSizing bugs.
// 5/16/02 - Add test to see if the grid is the activecontrol before setting focus.
}

interface
{$i wwIfDef.pas}

uses
  SysUtils, Windows, Messages, Classes, Graphics, Controls, StdCtrls,
  Forms, Grids, {DsgnIntf, }dialogs, dbtables, db, wwstr,
  wwtable, wwMemo, wwcommon, wwdbigrd, wwdbdatetimepicker, wwexport,
  {$ifdef win32}
  comctrls, wwriched,
  {$endif}
  Menus, wwdatsrc, wwdbedit, wwtypes, dbctrls, inifiles, registry;

type
  TwwFieldControlType = (fctNone, fctField, fctCheckBox, fctCustom, fctBitmap,
                         fctLookupCombo, fctComboBox, fctRichEdit, fctImageIndex,
                         fctURLLink);
  TwwOnInitMemoDlgEvent = procedure(Dialog : TwwMemoDlg) of object;
  TwwMemoUserButtonEvent = procedure(Dialog: TwwMemoDlg; Memo: TMemo) of object;
  TwwCreateDTPEvent = procedure(Sender: TObject;
       ADateTimePicker: TwwDBCustomDateTimePicker) of object;
  TwwDBGrid = class;

  TwwIniAttributes = class(TPersistent)
  private
     FFormName:string;
     FFileName, FSectionName, FDelimiter: string;
     FEnabled:Boolean;
     FSaveToRegistry : Boolean;
     FCheckNewFields: boolean;
     procedure SetFileName(val: string);
     procedure SetSectionName(val: string);
     procedure SetDelimiter(val: string);
     procedure SetEnabled(val: boolean);
     function GetSectionName : string;
     function GetFileName : string;
  public
     Owner: TComponent;
     property FormName:string read FFormName;
  published
     property Enabled: boolean read FEnabled write SetEnabled default False;
     property SaveToRegistry: boolean read FSaveToRegistry write FSaveToRegistry default False;
     property FileName: string read GetFileName write SetFileName;
     property SectionName: string read GetSectionName write SetSectionName;
     property Delimiter: string read FDelimiter write SetDelimiter;
     property CheckNewFields: boolean read FCheckNewFields write FCheckNewFields default false;
  end;

  TwwMemoDialog = class(TComponent)
  private
     FFont: TFont;
     FDataLink: TFieldDataLink;
     FMemoAttributes: TwwMemoAttributes;
     FCaption: String;
     FLeft, FTop, FWidth, FHeight: integer;

     { IP 2.0 additions }
     FUserButton1Click: TwwMemoUserButtonEvent;
     FUserButton2Click: TwwMemoUserButtonEvent;
     FOnInitDialog: TwwOnInitMemoDlgEvent;
     FOnCloseDialog: TwwOnInitMemoDlgEvent;
     FUserButton1Caption: string;
     FUserButton2Caption: string;
     FLines: TStrings;
     procedure SetLines(val: TStrings);
  protected
     procedure SetDataField(value: String);
     procedure SetDataSource(value : TDataSource);
     Function GetDataSource: TDataSource;
     Function GetDataField: String;
     procedure SetwwMemoAttributes(sel: TwwMemoAttributes);
     procedure SetFont(Value: TFont);
     procedure SetCaption(Value: String);
  public
     Form: TwwMemoDlg;  { Used by TwwMemoDlg }
     Patch: Variant;
     constructor Create(AOwner: TComponent); override;
     destructor Destroy; override;
     procedure DoInitDialog; virtual;  { called by wwmemo }
     procedure DoCloseDialog; virtual;  { called by wwmemo }

  published
     property DataSource: TDataSource read getDataSource write setDataSource;
     property DataField: String read getDataField write setDataField;
     function Execute: boolean; virtual;
     property Font: TFont read FFont write SetFont;
     property MemoAttributes : TwwMemoAttributes
        read FMemoAttributes write setwwMemoAttributes
        default [mSizeable, mWordWrap];
     property Caption: string read FCaption write setCaption;
     property Lines: TStrings read FLines write SetLines;

     property DlgLeft: integer read FLeft write FLeft;
     property DlgTop: integer read FTop write FTop;
     property DlgWidth: integer read FWidth write FWidth;
     property DlgHeight: integer read FHeight write FHeight;

     property OnInitDialog: TwwOnInitMemoDlgEvent read FOnInitDialog write FOnInitDialog;
     property OnCloseDialog: TwwOnInitMemoDlgEvent read FOnCloseDialog write FOnCloseDialog;
     property OnUserButton1Click: TwwMemoUserButtonEvent read FUserButton1Click write FUserButton1Click;
     property OnUserButton2Click: TwwMemoUserButtonEvent read FUserButton2Click write FUserButton2Click;
     property UserButton1Caption: string read FUserButton1Caption write FUserButton1Caption;
     property UserButton2Caption: string read FUserButton2Caption write FUserButton2Caption;

  end;


  TwwMemoOpenEvent =
     procedure (Grid: TwwDBGrid; MemoDialog: TwwMemoDialog) of object;

  TwwMemoCloseEvent =
     procedure (Grid: TwwDBGrid; Cancel: boolean) of object;

  TwwSelectRecordEvent =
     procedure (Grid: TwwDBGrid; Selecting: boolean; var Accept: boolean) of object;

  TwwSelectAllRecordEvent =
     procedure (Grid: TwwDBGrid; Selecting: boolean; var Accept: boolean) of object;

  TwwExportFieldEvent =
     procedure (Grid: TwwDBGrid; Field: TField; var Accept: boolean) of object;

  TwwExportSYLKFormatEvent =
     procedure (Grid: TwwDBGrid; Field: TField; var SYLKFormat:String) of object;

//PwwCustomControlItem = ^TwwCustomControlItem;

TwwDBGrid = class(TwwCustomDBGrid)
  private
    FSizingIndex, FSizingPos, FSizingOfs: integer;
    FMemoAttributes : TwwMemoAttributes;
    FIniAttributes : TwwIniAttributes;
    FExportOptions : TwwExportOptions;
    redrawingGrid: Boolean;
    initialized: Boolean;
    doneInitControls: boolean;
    drawingCell: Boolean;
//    currentComboBoxRow, currentComboBoxCol: integer;
    FOnMemoOpen: TwwMemoOpenEvent;
    FOnMemoClose: TwwMemoCloseEvent;
    FFixedCols: integer;
    FDirtyIni: boolean;
    inLinkActive: boolean;
    inTopLeftChanged: boolean;
    GridIsLoaded: boolean;
    FOnSelectRecord : TwwSelectRecordEvent;
    FOnSelectAllRecords : TwwSelectAllRecordEvent;
    FOnExportField : TwwExportFieldEvent;
    FOnExportSYLKFormat : TwwExportSYLKFormatEvent;
    FOnCreateDateTimePicker: TwwCreateDTPEvent;
    FLoadAllRTF: boolean;
    OrigSelected: TStrings;

    { Multi-selection support variables}
    Bookmarks: TList;
    FDependentComponents: Tlist;
    MakeCustomControlVisible: boolean;
    FDisableThemes: boolean;

//    FCustomControls: array of TwwCustomControlItem;
    Function GetTitleColor: TColor;
    procedure SetTitleColor(sel: TColor);
//    Function GetDataLineColor: TColor;
//    procedure SetDatalineColor(sel: TColor);

    Function GetDataSource: TDataSource;
    Procedure SetDataSource(val: TDataSource);

    procedure SetwwMemoAttributes(sel: TwwMemoAttributes);
    procedure CMDesignHitTest(var Msg: TCMDesignHitTest); message CM_DESIGNHITTEST;
    procedure WMLButtonDblClk(var Msg: TWMLButtonDblClk); message WM_LBUTTONDBLCLK;
    procedure CMCtl3DChanged(var Message: TMessage); message CM_CTL3DCHANGED;
    procedure WMChar(var Msg: TWMChar); message WM_CHAR;
    procedure WMPaint(var Message: TWMPaint); message WM_PAINT;

    procedure UpdateSelectedProperty;
    function GetDateTimePicker: TwwDBCustomDateTimePicker;
    procedure DrawSizingLine(const DrawInfo: TGridDrawInfo);

  protected
    SelectedRecordList: TStrings; { Internal buffers selected value }

    procedure ShowCurrentControl; virtual;
    procedure AdjustLeftCol; virtual;
    procedure CalcSizingState(X, Y: Integer; var State: TGridState;
      var Index: Longint; var SizingPos, SizingOfs: Integer;
      var FixedInfo: TGridDrawInfo); override;
    procedure CreateWnd; override;

    function CreateDateTimePicker: TwwDBCustomDateTimePicker; virtual;
    procedure DoCreateDateTimePicker(ADateTimePicker: TwwDBCustomDateTimePicker); virtual;

    procedure CalcRowHeight; override;

    procedure DoExit; override;
    procedure ColumnMoved(FromIndex, ToIndex: Longint); override;
    procedure ColWidthsChanged; override;
    procedure LinkActive(value: boolean); override;
    procedure SetFieldValue(ACol: Integer; val: string);
    function CanEditShow: Boolean; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: integer); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: integer); override;
    procedure MouseMove(Shift: TShiftState; X, Y: Integer); override;
    procedure ColExit; override;
    procedure TopLeftChanged; override;
    Function AllowCancelOnExit: boolean; override;

    procedure ToggleCheckBox(col, row: integer);
    procedure InitControls;
    procedure SetFixedCols(val: integer);
    function GetFixedCols: integer;
    procedure Paint; override;
    function IsWWControl(ACol, ARow: integer): boolean; override;
    procedure CallMemoDialog;
    Function findBookmark: TBookmark;

    Function CellColor(ACol, ARow: integer): TColor; override;
    procedure RefreshBookmarkList; override;
    procedure Scroll(Distance: Integer); override;
    procedure Loaded; override;
    procedure SelectRecordRange(bkmrk1, bkmrk2: TBookmark); virtual;
    Procedure RemoveSelected(bkmrk1, bkmrk2: TBookmark); virtual;
    Function IsSelectedRow(DataRow: integer): boolean; override;
    procedure RefreshActiveControl; virtual;
    function IsActiveControl: Boolean;

//    procedure PaintWindow(DC: HDC); override;

  public
    Patch: Variant;

    Function IsSelected: boolean; override;
    Function IsSelectedRecord: boolean;
    Procedure SelectRecord; override;
    Procedure UnselectRecord; override;
    Procedure SelectAll;
    Procedure UnselectAll; override;
    Procedure LoadFromIniFile; virtual;
    Procedure SaveToIniFile; virtual;
    procedure ClearControls;

    procedure FlushChanges; override;
    procedure KeyDown(var Key: word; Shift: TShiftState); override;
    Function GetRowCount: integer;
    Function GetColCount: integer;
    Function GetActiveRow: integer;
    Function GetActiveCol: integer;
    Procedure SetActiveRow(val: integer); {10/24/96 }
    Function GetActiveField: TField;
    Procedure SetActiveField(AFieldName: string);

    function IsRichEditCell(col, row: integer; var customEdit: TWinControl) : boolean;

    //4/19/2001-Make following procedures public for export unit.
    procedure GetControlInfo(AFieldName: string;
        var AControlType: string; var AParameters: string); override;
    Function GetFieldValue(ACol: integer): string; override;
    procedure DoExportField(Grid:TwwDBGrid; AField:TField; var Accept:Boolean); virtual;
    procedure DoExportSYLKFormat(Grid:TwwDBGrid; AField:TField; var SYLKFormat:String); virtual;
    procedure SetScrollBars(scrollVal: TScrollStyle);
    procedure RedrawGrid;
    procedure SetColumnAttributes; override;
    procedure DrawCell(ACol, ARow: Longint; ARect: TRect;  AState: TGridDrawState); override;
    procedure HideControls; override;                          { InfoPower documented method }
    function MouseCoord(X, Y: Integer): TGridCoord;           { InfoPower documented method }
//    procedure SetControlType(AFieldName: string;
//        AComponentType: TwwFieldControlType;
//        AParameters: string; AAlwaysPaints: boolean = False);
    procedure SetControlType(AFieldName: string;
        AComponentType: TwwFieldControlType;
        AParameters: string); //; AAlwaysPaints: boolean = False);
    procedure RefreshDisplay;                                 { InfoPower documented method }
    procedure SortSelectedList;                               { IP 2 documented method }
    procedure RestoreDesignSelected;

    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure ColEnter; override; { 3/29/97}

    property DateTimePicker: TwwDBCustomDateTimePicker read GetDateTimePicker;
    property InplaceEditor;  { Support in-cell editing events }
    property ColWidths;
    property GridLineWidth;
    property Canvas;
    property SelectedList: TList read Bookmarks;
    property TabStops;
    Procedure AddDependent(value: TComponent);
    Procedure RemoveDependent(value: TComponent);
    procedure ApplySelected; override;

  published
    property DisableThemes : boolean read FDisableThemes write FDisableThemes;
    property LineStyle;
    property ControlInfoInDataset;
    property ControlType;
    property PictureMaskFromDataSet;
    property PictureMasks;
    property Selected;
    property MemoAttributes : TwwMemoAttributes
        read FMemoAttributes write setwwMemoAttributes
        default [mSizeable, mWordWrap];
    property IniAttributes : TwwIniAttributes
        read FIniAttributes write FIniAttributes;
    property ExportOptions : TwwExportOptions read FExportOptions write FExportOptions;
    property TitleColor: TColor read getTitleColor write setTitleColor;
//    property DataLineColor: TColor read getDatalineColor write setDataLineColor;
    property OnExportField : TwwExportFieldEvent read FOnExportField write FOnExportField;
    property OnExportSYLKFormat : TwwExportSYLKFormatEvent read FOnExportSYLKFormat write FOnExportSYLKFormat;
    property OnMemoOpen : TwwMemoOpenEvent read FOnMemoOpen write FOnMemoOpen;
    property OnMemoClose : TwwMemoCloseEvent read FOnMemoClose write FOnMemoClose;
    property OnMultiSelectAllRecords : TwwSelectAllRecordEvent read FOnSelectAllRecords write FOnSelectAllRecords;
    property OnMultiSelectRecord : TwwSelectRecordEvent read FOnSelectRecord write FOnSelectRecord;
    property OnCreateDateTimePicker: TwwCreateDTPEvent
             read FOnCreateDateTimePicker write FOnCreateDateTimePicker;
    property OnLeftColChanged;
    property OnRowChanged;
    property OnCellChanged;

    property FixedCols : integer read getFixedCols write setFixedCols;
    property ShowHorzScrollBar;
    property ShowVertScrollBar;
    property EditControlOptions;
    property IndicatorButton;

    {$ifdef wwDelphi4Up}
    property Anchors;
    property BiDiMode;
    property ParentBiDiMode;
    {$endif}
    property Align;
    property BorderStyle;
    property Color;
    {$ifdef wwDelphi4Up}
    property Constraints;
    {$endif}
    property Ctl3D;
    property DataSource : TDataSource read getDataSource write setDataSource;
    property DefaultDrawing;
    property DragCursor;
    property DragMode;
    property EditCalculated;
    property Enabled;
    property Font;
    {$ifdef wwDelphi3Up}
    property ImeMode;// : TImeMode read getImeMode write setImeMode default imDontCare;
    property ImeName;// : string read getImeName write setImeName;
    {$endif}
    property KeyOptions;
    property MultiSelectOptions;
    property Options;
    property ParentColor;
    property ParentCtl3D;
    property ParentFont;
    property ParentShowHint;
    property PopupMenu;
    property ReadOnly;
    property RowHeightPercent;
    property ShowHint;
    property TabOrder;
    property TabStop;
    property TitleAlignment;
    property TitleFont;
    property TitleLines;
    property TitleButtons;
    property UseTFields;
    property Visible;
    property LoadAllRTF: boolean read FLoadAllRTF write FLoadAllRTf default False;
    property LineColors;
    property OnCalcCellColors;
    property OnCalcTitleAttributes;
    property OnColWidthChanged;
    property OnDrawGroupHeaderCell;
    property OnTitleButtonClick;
    property OnColEnter;
    property OnColExit;
    property OnDrawDataCell;
    property OnDblClick;
    property OnDragDrop;
    property OnDragOver;
    property OnEndDrag;
    property OnStartDrag; // 5/4/00 - publish OnStartDrag property
    property OnEnter;
    property OnExit;
    property OnKeyDown;
    property OnKeyPress;
    property OnKeyUp;
    property OnCreateHintWindow;
//    property OnValidationErrorUsingMask;

    property OnMouseDown;
    property OnMouseMove;
    property OnMouseUp;
    property IndicatorColor stored False;  // obsolete property
    property IndicatorIconColor;
    property OnCheckValue;
    property OnColumnMoved;
    property OnTopRowChanged;
    property OnCalcTitleImage;
    property OnDrawFooterCell;
    property OnDrawTitleCell;
    property OnFieldChanged;
    property OnUpdateFooter;
    property OnBeforePaint;
    property ImageList;
    property TitleImageList;
    property FooterColor;
    property FooterCellColor;
    property FooterHeight;
    property DragVertOffset;
    property PadColumnStyle;
    property PaintOptions;
    property OnURLOpen;
    property HideAllLines;

    property OnBeforeDrawCell;
    property OnAfterDrawCell;

end;

implementation

uses wwdbcomb,
{$ifdef wwDelphi6Up}
variants,
{$endif}
   wwintl,
   {$ifndef wwDelphi6Up}
   filectrl,
   {$Endif}
   wwcheckbox, Clipbrd, bde,
   wwradiogroup;

const wwCRLF = #13#10;

type
  TRichProtectClass = class(TObject)
     procedure RichProtectChange(Sender: TObject; StartPos,
       EndPos: Integer; var AllowChange: Boolean);
  end;

function sameRect(rect1, rect2: TRect): boolean;
begin
   result:=
      (rect1.left = rect2.left) and
      (rect1.right = rect2.right) and
      (rect1.top = rect2.top) and
      (rect1.bottom = rect2.bottom);
end;

    constructor TwwDBGrid.create(AOwner: TComponent);
    begin
      inherited Create(AOwner);

      OrigSelected:= Tstringlist.create;

      FIniAttributes:= TwwIniAttributes.create;
      with FIniAttributes do begin
         FileName := '';
         SectionName := '';
         Delimiter := ';;';
         Enabled := False;
         Owner := self;
      end;

      FExportOptions := TwwExportOptions.create(self);

      FDirtyIni:= True;
      redrawingGrid:= False;
      initialized:= False;
      doneInitControls:= False;
      drawingCell:= False;

      MemoAttributes := [mSizeable, mWordWrap];
      FFixedCols:= 0;
      inLinkActive:= False;

      Bookmarks:= TList.create;
      FDependentComponents:= TList.create;
      SelectedRecordList:= TStringList.create;

      GridIsLoaded:= False;
      AlwaysShowControls:= False;
      CurrentCustomEdit:= Nil;
      VirtualView := True;  { 3/11/98 - Auto-invalidate if grid rowcount or colcount changes }

      Patch:= VarArrayCreate([0, 5], varVariant);
      Patch[0]:= False; { 9/2/98 - True means the FieldChanged was already
                          called. Used by TwwDBCustomDBGrid }
      Patch[1]:= False; { If True, then bypass code to workaround Delphi 4 showing bug }
      Patch[2]:= 0;     { 12/7/98 - Contains SizingColumn when resizing a column }
      Patch[3]:= False;
      Patch[4]:= False; { If true, then Hidecontrols called after inheritd ColExit }
                        { This would cause the control's OnExit event to be called after
                          the OnColExit event }
      Patch[5]:= False; {1/9/2002 - Added for backwards compatibility when
                         exiting the grid error messages from onvalidate were not displayed.
                         Using a Patch variable to provide solution while studying impact.}
    end;

    destructor TwwDBGrid.Destroy;
    var i: integer;
    begin
      if FIniAttributes.Enabled then
        try SaveToIniFile;
        finally
        end;

      OrigSelected.Free;

      for i:= 0 to bookmarks.count-1 do begin
         if (datasource<>nil) and (datasource.dataset<>nil) then
            datasource.dataset.FreeBookmark(TBookmark(bookmarks.items[i]));
      end;
      bookmarks.Free;
      bookmarks:= Nil;

      { 5/13/98 - Free shift select bookmark}
      if ShiftSelectMode and (ShiftSelectBookmark<>Nil) and
         (datasource<>nil) and (datasource.dataset<>nil) then
      begin
         ShiftSelectMode:= False;
         datasource.dataset.FreeBookmark(ShiftSelectBookmark);
      end;

      for i:= 0 to FDependentComponents.count-1 do begin
         TwwCheatCastNotify(FDependentComponents[i]).notification(self, opRemove);
      end;
      FDependentComponents.Free;

//      for i:= 0 to FCustomControls.count-1 do TwwCustomControlItem(FCustomControls[i]).Free;
//      FCustomControls.Free;
//      if FCustomControls<>nil then
//         FreeMem(FCustomControls);
//      FCustomControls:=nil;

      SelectedRecordList.Free;

      FIniAttributes.Free;
      FExportOptions.Free;

      inherited Destroy;
    end;

    procedure TwwDBGrid.SetFixedCols(val: integer);
    begin
       if (csDesigning in ComponentState) then begin
          if ((dataSource<>Nil) and (dataSource.dataSet<>Nil) and
             (dataSource.dataSet.active) and (val+xIndicatorOffset>=ColCount)) or
             (val<0) then
          begin
             MessageDlg('Invalid value for FixedCols', mtWarning, [mbok], 0);
             exit;
          end
       end;

       FFixedCols:= val;
       LayoutChanged;
    end;

    Function TwwDBGrid.GetFixedCols: integer;
    begin
       result:= FFixedCols;
    end;

    Function TwwDBGrid.GetDataSource: TDataSource;
    begin
       if (inherited DataSource) is TDataSource then
          result:= (inherited DataSource) as TDataSource
       else result:= Nil;
    end;

    Procedure TwwDBGrid.SetDataSource(val: TDataSource);
    begin
       Inherited DataSource:= Val;
    end;

    procedure TwwDBGrid.SetwwMemoAttributes(sel : TwwMemoAttributes);
    begin
        FMemoAttributes:= sel;
        redrawGrid;
    end;

    Function TwwDBGrid.GetTitleColor: TColor;
    begin
       result:= inherited TitleColor;
    end;

    procedure TwwDBGrid.SetTitleColor(sel: TColor);
    begin
       if sel<>inherited TitleColor then
       begin
         inherited TitleColor:= sel;
         LayoutChanged;
       end
    end;

{    Function TwwDBGrid.GetDataLineColor: TColor;
    begin
       result:= inherited DataLineColor;
    end;

    procedure TwwDBGrid.SetDataLineColor(sel: TColor);
    begin
       if sel<>inherited TitleColor then
       begin
         inherited DataLineColor:= sel;
         LayoutChanged;
       end
    end;
}
    procedure TwwDBGrid.SetScrollBars(scrollVal: TScrollStyle);
    begin
      ScrollBars:= scrollVal;
    end;

procedure TwwDBGrid.RedrawGrid;
var i: integer;
    haveCalculatedField: boolean;
//    form: TComponent;
begin
   if redrawingGrid then exit;
   if Selected = Nil then exit;
   if (dataSource=Nil) then exit;
   if (dataSource.dataSet=Nil) then exit;
   if not (wwDataSet(DataSource.dataSet)) then
   begin
      MessageDlg('wwGrid must use an InfoPower compatible TDataSet.',
          mtInformation, [mbok], 0);
      DataSource := Nil;
      exit;
   end;

   ResetProportionalWidths;

   if dgProportionalColResize in Options then
      LayoutChanged;  // resets number of columns

   InitControls;

   try
      dataSource.dataSet.disableControls;
      CurrentCustomEdit:= nil;  { 4/9/98 - Clear currentcustomedit when table is made active }
      if ControlInfoInDataSet then
         with datasource do
            wwDataSetRemoveObsolete(dataset,
               wwGetLookupFields(dataset), wwGetLookupLinks(dataset),
                wwGetControlType(dataSet));
//      if ecoSearchOwnerForm in FEditControlOptions then form:= wwGetOwnerFrameOrForm(self)
//      if ecoSearchOwnerForm in FEditControlOptions then form:= wwGetOwnerForm(self)
//      else form:= GetParentForm(self) as TCustomForm; { -ksw (6/22/98) }

//      if ControlInfoInDataSet then
//         wwDataSetRemoveObsoleteControls(form, datasource.dataset);

      redrawingGrid:= True;

      { If no selection then don't override }
      { If running program and have calculated field then don't change visibility }
      if selected.Count>0 then begin
         haveCalculatedField:= False;
         for i:= 0 to dataSource.dataSet.fieldCount-1 do begin
            if (datasource.dataset.fields[i].calculated) then
               haveCalculatedField:= True;
         end;

         if (csDesigning in ComponentState) or (not haveCalculatedField) then
         begin
            ApplySelected;
         end;

      end;

      {InitControls could change row height so update }
      if (csDesigning in ComponentState) then
      begin
         if useTFields then updateSelectedProperty;
         UpdateRowCount;
      end;


   finally
      dataSource.dataSet.enableControls;
      redrawingGrid:= False;
      initialized:= True;
   end;
end;


procedure TwwDBGrid.LinkActive(value: boolean);
begin
   inLinkActive:= True;

   if csDestroying in ComponentState then        {9/30/99 - Added to save when using datamodule}
      if FIniAttributes.Enabled then SaveToIniFile;

   if (FDateTimePicker<>Nil) then begin
      wwSetControlDataField(FDateTimePicker, ''); {8/5/98 }
   end;
   inherited linkActive(value);
   if value then
   begin
      redrawGrid;
   end;
   inLinkActive:= False;
end;

{ Don't allow insertion of record to cancel if combo is showing. }
Function TwwDBGrid.AllowCancelOnExit: boolean;
begin
   result:= True;
end;

procedure TwwDBGrid.DoExportSYLKFormat(Grid:TwwDBGrid; AField:TField; var SYLKFormat:String);
begin
  if Assigned(FOnExportSYLKFormat) then FOnExportSYLKFormat(self, AField, SYLKFormat);
end;

procedure TwwDBGrid.DoExportField(Grid:TwwDBGrid; AField:TField; var Accept:Boolean);
begin
  if Assigned(FOnExportField) then FOnExportField(self, AField, Accept);
end;

procedure TwwDBGrid.DoExit;
begin
   HideControls;
   HideEditor;
   inherited doExit;
end;

  procedure TwwDBGrid.UpdateSelectedProperty;
  var pf: TCustomForm;
  begin
    if redrawingGrid then exit;
    if Selected = Nil then exit;
    if dataSource=Nil then exit;
    if dataSource.dataSet = Nil then exit;

    if (initialized) then begin
       pf := GetParentForm(self);
       if pf=nil then exit;

       with pf do begin
          if (Designer<>Nil) then begin
             wwDataSetUpdateSelected(datasource.dataset, selected);
          end;
       end;
    end;
  end;

  procedure TwwDBGrid.ApplySelected;
  begin
    if Selected = Nil then exit;

    // Reset OrigColWidths
    ResetProportionalWidths;

    if UseTFields then begin
       if dataSource=Nil then exit;
       if dataSource.dataSet = Nil then exit;
       wwDataSetUpdateFieldProperties(dataSource.dataSet,  selected);
       if selected.count>0 then
          LayoutChanged;  // 4/8/01 - If selected was changed, we need to refresh in
                          // case scrollbars disappear - Otherwise rowcount is 1 too small
    end
    else begin
       RefreshDisplay;
    end;

    RefreshActiveControl; { 2/19/00 - Update control information }
  end;


procedure TwwDBGrid.AdjustLeftCol;
var i: Integer;
begin
   if (inherited FixedCols<> FFixedCols+xIndicatorOffset) and
      (datasource<>Nil) and (datasource.dataset<>nil) and
      (datasource.dataset.active) then
   begin
      if (FFixedCols+xIndicatorOffset<ColCount) and (FFixedCols>=0) then
      begin
         inherited FixedCols:= FFixedCols + xIndicatorOffset;
         if (dgFixedEditable in Options) and (LeftCol=inherited FixedCols) then
            SelectedIndex:= 0;

         for i:= 0 to FFixedCols+xIndicatorOffset do TabStops[i]:= False;
      end
   end;
end;

procedure TwwDBGrid.SetColumnAttributes;
var i: integer;
    customEdit: TWinControl;
    ControlType, Parameters: wwSmallString;
begin
  if useTFields and (not inLinkActive) then
     updateSelectedProperty;

   { Update fixed columns if changed }
   AdjustLeftCol;
{   if (inherited FixedCols<> FFixedCols+xIndicatorOffset) and
      (datasource<>Nil) and (datasource.dataset<>nil) and
      (datasource.dataset.active) then
   begin
      if (FFixedCols+xIndicatorOffset<ColCount) and (FFixedCols>=0) then
      begin
         inherited FixedCols:= FFixedCols + xIndicatorOffset;
         if (dgFixedEditable in Options) and (LeftCol=inherited FixedCols) then
            SelectedIndex:= 0;

         for i:= 0 to FFixedCols+xIndicatorOffset do TabStops[i]:= False;
      end
   end;
}
  inherited setColumnAttributes;

  { Enable tabstops for calculated columns with a lookup control attached to it }
  if not DataLink.active then exit;

  for I := 0 to FieldCount - 1 do begin
    with Fields[I] do
       if Calculated then begin
          if isCustomEditCell(i+xIndicatorOffset, 1, customEdit) then
          begin
             TabStops[I + xIndicatorOffset] := True
          end
          else if isSelectedCheckbox(i+xIndicatorOffset) then
          begin
             TabStops[I + xIndicatorOffset] := True;
          end
          else begin
             GetControlInfo(FieldName,
                    ControlType, Parameters);
             if (ControlType = 'Bitmap') or
                (ControlType = 'ImageIndex') then TabStops[I + xIndicatorOffset] := True;
          end
       end
  end;

  RefreshActiveControl;  // 1/30/01 - Need to call or first column can have problems if datetime field
end;
{
Function TwwDBGrid.IsSelectedCheckbox(ACol: integer): boolean;
var tempField: TField;
begin
    if isCheckBox(ACol, 1, dummy1, dummy2) then
    begin
       tempField:=GetColField(dbCol(ACol));
       if tempField=nil then result:= False
       else result:= (lowercase(tempField.fieldName)='selected');
    end
    else result:= False;
end;
}
function TwwDBGrid.MouseCoord(X, Y: Integer): TGridCoord;
{$ifdef wwdelphi4up}
var Loc: TRect;
    i:Integer;
{$endif}
begin
   result:= inherited MouseCoord(X,Y);

   {$ifdef wwdelphi4up}  { 10/27/98 }
   if UseRightToLeftAlignment and (FixedCols>0) then
   begin
      for i:= 0 to ColCount-1 do begin
         Loc:= CellRect(i, result.y);
         if loc.left<x then
         begin
            result.x:= i;
            break;
         end
      end
   end;
   {$endif}
end;

procedure TwwDBGrid.HideControls;
var TriedToSetFocus: boolean;
begin
   if (currentCustomEdit<>Nil) and currentCustomEdit.visible and
      (currentCustomEdit.parent=self) then  { 5/1/97 - Only hide if grid is parent of control }
   begin
      TriedToSetFocus:=false;
      if (currentCustomEdit.focused) or
         (GetParent(GetFocus)=currentCustomEdit.handle) then  // i.e. inplaceeditor of datainspector
      begin
         currentcustomedit.left:= clientwidth+10;
         TriedToSetFocus:=True;
         setFocus;
      end
      else if (screen.activecontrol<>nil) and
         (screen.activecontrol.parent=currentcustomedit) then
      begin
         currentcustomedit.left:= clientwidth+10;
         TriedToSetFocus:=True;
         setFocus;
      end;

      // 4/16/2002 - If an exception is raised in the onvalidate event of the tfield for a custom control
      // then the focus could still be the custom edit and this means the grid failed to
      // get focus and thus currentcustomedit should not be set to not visible.
      if Focused or (not TriedToSetFocus) then
      begin
        SkipErase:= True;
        currentCustomEdit.visible:= False;
        SkipErase:= False;
      end
      else sysutils.abort; // Fail to set the focus so an exception was likely thrown, don't hide control
   end
end;

function TwwDBGrid.IsActiveControl: Boolean;
var
  H: Hwnd;
  ParentForm: TCustomForm;
begin
  Result := False;
  ParentForm := GetParentForm(Self);
  if Assigned(ParentForm) then
  begin
    if (ParentForm.ActiveControl = Self) then
      Result := True
  end
  else
  begin
    H := GetFocus;
    while IsWindow(H) and (Result = False) do
    begin
      if H = WindowHandle then
        Result := True
      else
        H := GetParent(H);
    end;
  end;
end;

Procedure TwwDBGrid.Paint;
var
   tempFldName: string;
   index: integer;
begin
   RefreshBookmarkList;

   if not ShowVertScrollBar then SetScrollRange(Self.Handle, SB_VERT, 0, 0, False);

   { combo field has disappeared so hide combo control }
   if (currentCustomEdit<>Nil) and currentCustomEdit.visible and
      (datasource<>Nil) and (datasource.dataset<>nil) and
      (datasource.dataset.active) then
   begin
       tempFldName:= wwGetControlDataField(currentCustomEdit);
       if tempFldName<>'' then begin
         if useTFields then begin
            if (datasource.dataset.findField(tempFldName)=Nil) or
               not dataSource.dataSet.fieldByName(tempFldName).visible then
                  HideControls;
         end
         else begin
            if not wwFindSelected(Selected, tempFldName, index) then
                HideControls;
         end
       end
   end;
   MakeCustomControlVisible:= False;

   inherited paint;
//   ShowCurrentControl;
end;

Function TwwDBGrid.CellColor(ACol, ARow: integer): TColor;
begin
   if ACol>FFixedCols then result:= Color
   else result:= TitleColor;
end;

procedure TwwDBGrid.DrawCell(ACol, ARow: Longint; ARect: TRect;  AState: TGridDrawState);
var value: string;
    OldActive: integer;
    EditableCell: Boolean;
    lookupControl: TWinControl;
    tempFld: TField;
    tempRect,OrigRect: TRect;

  procedure GetAbsolutePos(var ALeft, ATop: integer);
  var curObject: TWinControl;
      lastObject: TWinControl;
  begin
     curObject:= self;
     lastObject:= self;
     ALeft:= curObject.left;
     ATop:= curObject.top;

     while (curObject<>Nil) do begin
        curObject:= curObject.parent;
        if curObject is TCustomform then break;

        if curObject.containsControl(lastObject) then begin
           ALeft:= ALeft + curObject.left;
           ATop:= ATop + curObject.top;
        end;
     end;
  end;

  function IsEditableCell(DataCol, DataRow: Integer;
  const Value: string; AState: TGridDrawState): Boolean;
  begin
    Result := (gdSelected in AState) or
//              ((DataRow=dbRow(Row)) and (dgRowSelectEditable in Options));
              ((DataRow=dbRow(Row)) and (PaintOptions.ActiveRecordColor<>clNone));
    if Result then
    begin
       if not ((dgAlwaysShowSelection in Options) or
          (FFocused and not IsDropDownGridFocused)) then Result:= False;
    end;
  end;

begin
   if drawingCell then exit; { Avoid recursion }
   drawingCell:= True;

   if (row=ARow) and (col=ACol) and
//      ShouldShowCustomControls and
      isCustomEditCell(ACol, ARow, lookupControl) and
     (ShouldShowCustomControls or (lookupControl is TwwExpandButton)) then
   begin
      currentCustomEdit:= lookupControl;
      MakeCustomControlVisible:=True;

      with Canvas do begin
         EditableCell := IsEditableCell(ACol, dbRow(ARow), Value, AState);

         if (gdSelected in AState) and (not (csDesigning in ComponentState)) then
         begin
            if (currentCustomEdit<>Nil) and (currentCustomEdit.parent=self) and
               (ValidParentForm(Self).ActiveControl = currentCustomEdit) then
            begin
               {7/19/97 - Avoid flicker, previously checked BoundsRect}
               TempRect:= ARect;

               if AdjustBoundsRect(CurrentCustomEdit) then
                  InflateRect(TempRect, -1, -1);

               if (currentCustomEdit.BoundsRect.left<>TempRect.Left) or
                  (currentCustomEdit.BoundsRect.right<>TempRect.right) then
               begin
                  if Columns[dbCol(ACol)].DisableSizing then
                  begin
                     if TempRect.Right-TempRect.Left<currentCustomEdit.Width then
                       TempRect.Right:= TempRect.Left + currentCustomEdit.Width;
                     if TempRect.Bottom-TempRect.Top<currentCustomEdit.Height then
                       TempRect.Bottom:= TempRect.Top + currentCustomEdit.Height;
                     if tempRect.Top+ currentcustomEdit.height>Parent.ClientHeight then
                     begin
                        tempRect.Top:= ARect.Bottom-currentCustomedit.Height;
                        tempRect.Bottom:= ARect.Bottom;
                     end;
                  end;

                  {$ifdef wwDelphi4Up}
                  if (Canvas.CanvasOrientation = coRightToLeft) then { 9/25/98 - Support bidi mode }
                  begin
                     TempRect.Right := ClientWidth - ARect.Left;
                     TempRect.Left := tempRect.Right - (ARect.Right-ARect.Left) + 1;
                  end;
                  {$endif}
                  currentCustomEdit.BoundsRect:= TempRect;
               end

            end
            else if EditableCell and (ValidParentForm(Self).ActiveControl = Self) then
            begin
              { Clear buffer if changing rows so old value isn't drawn at all}
              OldActive:= DataLink.ActiveRecord;
              Value:= '';
              try
                 DataLink.ActiveRecord:= dbRow(ARow)+RowOffset;

                 if wwIsClass(currentCustomEdit.classType, 'TwwDBCustomLookupCombo') then
                 begin
                    tempFld:= GetColField(dbCol(ACol));
                    if tempFld<>Nil then
                       value:= tempFld.asString
                 end
                 else value:= GetFieldValue(dbCol(ACol));

              finally
                 DataLink.ActiveRecord:= OldActive;
              end;

              { This is here for screen repainting reasons, otherwise screen is painted wrong then right. }
              if not (currentcustomedit is TCustomRichEdit) and
                 not wwIsClass(currentCustomEdit.classType, 'TfcTreeCombo') and // 10/28/01 - Otherwise mapped values not respected
                (currentCustomEdit is TCustomEdit) then // 1/29/01
                 TEdit(currentCustomEdit).Text:= Value;


              if (currentCustomEdit.parent <> Self) then
              begin
                 currentCustomEdit.parent:= Self;
                 TEdit(currentCustomEdit).ctl3d:= False;
                 if not wwIsClass(currentCustomEdit.classType, 'TwwDataInspector') then
                    TEdit(currentCustomEdit).BorderStyle:= bsNone;
              end;

              { 1/25/98 - Moved to after setting ctl3d and borderstyle }
              TempRect:= ARect;
              TempRect:= CellRect(Col, Row);
              OrigRect:= TempRect;
              if AdjustBoundsRect(CurrentCustomEdit) then
                 InflateRect(TempRect, -1, -1);
              if not sameRect(currentCustomEdit.BoundsRect, TempRect) then begin
                  if Columns[dbCol(Col)].DisableSizing then
                  begin
                     if TempRect.Right-TempRect.Left<currentCustomEdit.Width then
                       TempRect.Right:= TempRect.Left + currentCustomEdit.Width;
                     if TempRect.Bottom-TempRect.Top<currentCustomEdit.Height then
                       TempRect.Bottom:= TempRect.Top + currentCustomEdit.Height;
                     if tempRect.Top+ currentcustomEdit.height>Parent.ClientHeight then
                     begin
                        tempRect.Top:= OrigRect.Bottom-currentCustomedit.Height;
                        tempRect.Bottom:=OrigRect.Bottom;
                     end;
                  end;

                  {$ifdef wwDelphi4Up}
                  if (Canvas.CanvasOrientation = coRightToLeft) then { 9/25/98 - Support bidi mode }
                  begin
                     TempRect.Right := ClientWidth - ARect.Left;
                     TempRect.Left := tempRect.Right - (ARect.Right-ARect.Left) +1;
                  end;
                  {$endif}
                  currentCustomEdit.BoundsRect := TempRect;
              end;
              drawingCell:= False;
              exit;

            end
         end;
      end;
   end;


   inherited DrawCell(ACol, ARow, ARect, AState);

   { Make cells 3D style }
//   if DrawCellInfo.DefaultDrawHorzLines then
{   if DefaultDrawing then }Draw3DLines(ARect, ACol, ARow, AState);

   drawingCell:= False;

end;

{ Override so checkboxes in grid don't show underlying text }
function TwwDBGrid.IsWWControl(ACol, ARow: integer): boolean;
var fldName: string;
    ControlType, Parameters, tempName: string;
    Apos: integer;
    IsCustomControl: boolean;
begin
   result:= False;
   if not isValidCell(ACol, ARow) then exit;
   fldName:= DataLink.fields[dbCol(ACol)].fieldName;
   GetControlInfo(FldName, ControlType, Parameters);
   IsCustomControl:= IsWWEditControl(ControlType);

   result:= (ControlType='Bitmap') or (ControlType='ImageIndex') or
            (ControlType='CheckBox') or IsCustomControl or
            (not (ecoDisableDateTimePicker in EditControlOptions) and { Fix - 8/13/98 }
            (DataLink.fields[dbCol(ACol)] is TDateTimeField));
   if isCustomControl then
   begin
      APos:= 1;
      tempName:= strGetToken(Parameters, ';', APos);
      if GetComponent(tempName)=nil then result:= false;
   end;

end;

function TwwDBGrid.CanEditShow: Boolean;
begin
   Result:= inherited CanEditShow;

   if Result then
   begin
      if (dgAlwaysShowEditor in Options) and not Focused and
          (inplaceEditor<>Nil) and not inplaceEditor.visible then
         Result:= False {(ValidParentForm(Self).ActiveControl = Self)}
      else if isWWControl(col, row) then result:= False
      else if isMemoField(col, row) then result:= False;
   end
end;

{ Update checkbox }
procedure TwwDBGrid.SetFieldValue(ACol: Integer; val: string);
begin
  if (ACol >= 0) and Datalink.Active and (ACol < DataLink.FieldCount) then
    Datalink.Fields[ACol].Text:= Val;
end;


function TwwDBGrid.IsRichEditCell(
        col, row: integer;
        var customEdit: TWinControl) : boolean;
var fldName: string;
    i: integer;
    controlType: TStrings;
    APos: integer;
begin
   result:= False;
   if not isValidCell(col, row) then exit;
   fldName:= DataLink.fields[dbCol(col)].fieldName;

   { 8/14/97 - Optimized logic to speed painting of grid }
   controlType:= GetControlType;
   for i:= 0 to ControlType.count-1 do begin
      APos:= 1;
      if strGetToken(controlType[i], ';', APos)<>fldName then continue;
      if strGetToken(controlType[i], ';', APos)='RichEdit' then
      begin
         customEdit:= GetComponent(strGetToken(controlType[i], ';', APos));
         result:= True;
         break;
      end
   end
end;

//procedure TwwDBGrid.SetControlType(AFieldName: string; AComponentType: TwwFieldControlType;
//        AParameters: string; AAlwaysPaints: boolean = False);
procedure TwwDBGrid.SetControlType(AFieldName: string; AComponentType: TwwFieldControlType;
        AParameters: string);
var componentTypeStr: string;
    customEdit: TWinControl;
    TempComponent: TComponent;
begin
   case AComponentType of
     fctNone, fctField: componentTypeStr:= '';
     fctURLLink: componentTypeStr:= 'URL-Link';
     fctCustom, fctComboBox, fctLookupCombo, fctRichEdit: begin
         { 9/4/97 - fctRichEdit same path as customEdit}
         componentTypeStr:=WW_DB_EDIT;
         if AComponentType=fctRichEdit then componentTypeStr:= 'RichEdit';

         customEdit:= GetComponent(AParameters);  { 1/22/97 - Change customEdit properties immediately }
         if (customEdit<>Nil) and
            (ShouldShowCustomControls or (customEdit is TwwExpandButton)) then
//            (not (ecoDisableCustomControls in EditControlOptions)) then
         begin
            customEdit.visible:= False;
//            if (customEdit is TwwExpandButton) and
//               (TwwExpandButton(customEdit).grid<>nil) then
//               TwwExpandButton(customEdit).grid.visible:= false;
            customEdit.parent:= self;

            wwSetControlDataSource(customEdit, dataSource);
            wwSetControlDataField(customEdit, AFieldName);

            {  !!!!! Cheating casts to make protected properties public}
            TwwDBEdit(customEdit).ctl3d:= False;
            if AComponentType <> fctRichEdit then { 9/18/99 - Don't set font if richedit }
               TwwDBEdit(customEdit).font:= self.font;
            if not wwIsClass(CustomEdit.classType, 'TwwDataInspector') then
               TwwDBEdit(customEdit).BorderStyle:= bsNone;

            // Don't support scrollbars for inspector as then text gets cutoff in csPaintCopyState
            // If find way to support csPaintCopy, then we can remove this restriction
            if wwIsClass(CustomEdit.classtype, 'TwwDataInspector') then
               TDrawGrid(customedit).ScrollBars:= ssNone;
         end
       end;
     fctCheckbox: componentTypeStr:= 'CheckBox';
     fctBitmap: componentTypeStr:= 'Bitmap';
     fctImageIndex: componentTypeStr:= 'ImageIndex';
     else componentTypeStr:= '';
   end;

   if ControlInfoInDataSet then
   begin
      TempComponent:= Datasource.dataset;
      if (DataSource.DataSet=nil) or (wwGetControlType(Datasource.dataset)=nil) then TempComponent:= self;
   end
   else TempComponent:= self;

//   if AAlwaysPaints then AParameters:= AParameters+';T'
//   else AParameters:= AParameters + ';F';
   wwDataSet_SetControl(TempComponent,
      AFieldName, componentTypeStr, AParameters);
end;

procedure TwwDBGrid.RefreshDisplay;
var CustomEdit: TWinControl;
begin
   doneInitControls:= False;
   InitControls;
   LayoutChanged;

   // 8/13/02 - Clear CurrentCustomEdit (this code deemed necessary if user
   // changes control information when changing records).
   // Otherwise if active column is being changed, the inplaceeditor
   // can get disabled
   if not
     (isCustomEditCell(Col, Row, customEdit) and
     (ShouldShowCustomControls or (customEdit is TwwExpandButton))) then
     CurrentCustomEdit:=nil;
end;

{ Initialize controls to have the following attributes }
{ 1. This grid as parent
{ 2. Visible is False
{ 3. DataSource is this grid's datasource
{ 4. Set field later at time it is shown
}
{4/28/97 - Allow the same control to be attached more than once }
procedure TwwDBGrid.InitControls;
var
    i: integer;
    parts : TStrings;
    dbLookupComboBox: TWinControl;
    controlType: TStrings;
begin
   if (doneInitcontrols) and not (csDesigning in ComponentState) then exit;
   if (dataSource=Nil) then exit;
   if (dataSource.dataSet=Nil) then exit;
   if (csLoading in ComponentState) then exit;
   if not GridIsLoaded then exit;
   if (ecoDisableCustomControls in EditControlOptions) then exit;


   parts:= TStringList.create;

   with dataSource do begin
      controlType:= GetControlType;
      for i:= 0 to ControlType.count-1 do begin
         strBreakapart(ControlType[i], ';', parts);
         if parts.count<2 then continue;

         if isWWEditControl(parts[1]) or (parts[1]='RichEdit') then begin
            dbLookupComboBox:= GetComponent(parts[2]);
            if (dbLookupComboBox<>Nil) then begin
               if (csDesigning in ComponentState) then continue;
               dbLookupComboBox.visible:= False;
//               if (dblookupcombobox is TwwExpandButton) and
//                  (TwwExpandButton(dblookupcombobox).grid<>nil) then
//                  TwwExpandButton(dblookupcombobox).visible:= false;
               dbLookupComboBox.parent:= self;
               wwSetControlDataSource(dbLookupComboBox, self.dataSource);
               wwSetControlDataField(dbLookupComboBox, parts[0]);

               {  !!!!! Cheating casts to make protected properties public}
               TwwDBEdit(dbLookupComboBox).ctl3d:= False;
               TwwDBEdit(dbLookupComboBox).font:= self.font;
               if not wwIsClass(dblookupcombobox.classType, 'TwwDataInspector') then
                  TwwDBEdit(dbLookupComboBox).BorderStyle:= bsNone;

               // Don't support scrollbars for inspector as then text gets cutoff in csPaintCopyState
               // If find way to support csPaintCopy, then we can remove this restriction
               if wwIsClass(dblookupcombobox.classtype, 'TwwDataInspector') then
                  TDrawGrid(dblookupcombobox).ScrollBars:= ssNone;

            end
         end
      end;
   end;

   doneInitControls:= True;
   parts.free;
end;

procedure TwwDBGrid.CMCtl3DChanged(var Message: TMessage);
begin
   if csFramed in ControlStyle then redrawGrid;
end;

procedure TwwDBGrid.ColExit;
begin
   if patch[4]=True then inherited ColExit;

   if not (csDesigning in ComponentState) and
          ((ValidParentForm(Self).ActiveControl = Self) or
           (ValidParentForm(Self).ActiveControl = currentCustomEdit)) then  { Hide customedit }
   begin
      if currentCustomEdit<>Nil then
      begin
         HideControls;
         currentCustomEdit:= nil;
      end
   end;

   if patch[4]=false then inherited colExit;
end;

{ This code necessary to handle when column has changed when the combobox
  has focus }
procedure TwwDBGrid.TopLeftChanged;
var Loc: TRect;
    TempRect: TRect;
   Procedure ResetTopRow(val: integer);
   begin
      inTopLeftChanged:= True;
      TopRow:= val;
      inTopLeftchanged:= False;
   end;
   Procedure ResetLeftcol(val: integer);
   begin
      inTopLeftChanged:= True;
      LeftCol:= val;
//      AdjustLeftCol;
      inTopLeftchanged:= False;
   end;

begin
   if inTopLeftChanged then exit;

   if dgRowSelect in Options then begin { 8/13/96 Fix - Override toprow in case TCustomGrid changed it }
      if (dgTitles in Options) then begin
         if (TopRow<>1) then ResetTopRow(1)
      end
      else if (TopRow<>0) then ResetTopRow(0);
   end;

   if dgFixedEditable in Options then begin
//       ResetLeftCol(3);;
   end;

   inherited TopLeftChanged;

   if (currentCustomEdit<>Nil) then begin
     if currentCustomEdit.visible then begin
        Loc:= CellRect(Col, Row);
        if IsRectEmpty(Loc) then currentCustomEdit.Hide
        else begin
           TempRect:= CellRect(Col, Row);
           if AdjustBoundsRect(CurrentCustomEdit) then
              InflateRect(TempRect, -1,-1);

           if not sameRect(currentCustomEdit.BoundsRect, TempRect) then
           begin
              HideControls;
              Invalidate;
           end
        end
     end
   end;

end;

{ Override so it allows column resizing in design mode even when DefaultFields is True }
procedure TwwDBGrid.CMDesignHitTest(var Msg: TCMDesignHitTest);
var yTitleOffset: integer;
begin
  Msg.Result := Longint(BOOL(Sizing(Msg.Pos.X, Msg.Pos.Y)));

  if dgTitles in Options then yTitleOffset:= 1
  else yTitleOffset:= 0;

  if Msg.Result = 0 then
    with MouseCoord(Msg.Pos.X, Msg.Pos.Y) do
      if (X >= xIndicatorOffset) and (Y < yTitleOffset) then Msg.Result := 1;

  if (Msg.Result = 1) and ((DataLink = nil) or
    not DataLink.Active) then
    Msg.Result := 0;
end;

procedure TwwDBGrid.SelectRecordRange(bkmrk1, bkmrk2: TBookmark);
var
   curBookmark: Tbookmark;
   res: CmpBkmkRslt;
   ScrollCount, currentrow, moveByCount: integer;
   accept: boolean;

   Function LessThan(bookmark1, bookmark2: TBookmark): boolean;
   begin
       res:= wwDataSetCompareBookmarks(DataSource.DataSet, bookmark1, bookmark2);
{       dbiCompareBookmarks((datasource.dataset as TDBDataSet).handle, bookmark1, bookmark2, res);}
       if CompareBookmarksAltMethod then
          result:= integer(res)<0
       else
          result:= integer(res)=CmpLESS;
   end;

begin
   if (bkmrk1=nil) or (bkmrk2=nil) then exit; { 6/11/98 Invalid bookmarks so exit }

   with DataLink.Dataset do begin
      currentRow:= GetActiveRow;

      DisableControls;

     try

      if Lessthan(bkmrk1, bkmrk2) then
      begin
         RemoveSelected(bkmrk1, bkmrk2); { Remove all selected records in range before selecting}
         curBookmark:= GetBookmark;

         { 3/17/99 - Fire event }
         accept:= True;
         if Assigned(FOnSelectRecord) then FOnSelectRecord(self, True, Accept);
         if accept then bookmarks.add(curBookmark);

         while Lessthan(curBookmark, bkmrk2) do
         begin
            Next;
            if Eof then break;
            curBookmark:= GetBookmark;

            { 3/17/99 - Fire event }
            accept:= True;
            if Assigned(FOnSelectRecord) then FOnSelectRecord(self, True, Accept);
            if accept then bookmarks.add(curBookmark);

         end;
         Gotobookmark(bkmrk1);
      end
      else try  {12/02/97 - Added try block on gotobookmark to catch exception when bkmrk2 is invalid}
         Gotobookmark(bkmrk2);
         RemoveSelected(bkmrk2, bkmrk1); { Remove all selected records in range before selecting}

         curBookmark:= GetBookmark;

         { 3/17/99 - Fire event }
         accept:= True;
         if Assigned(FOnSelectRecord) then FOnSelectRecord(self, True, Accept);
         if accept then bookmarks.add(curBookmark);

         while Lessthan(curBookmark, bkmrk1) do
         begin
            if DataLink.ActiveRecord<VisibleRowCount-1 then
               DataLink.ActiveRecord:= DataLink.ActiveRecord + 1
            else begin
               Next;
               if Eof then break;
            end;

            curBookmark:= GetBookmark;

            { 3/17/99 - Fire event }
            accept:= True;
            if Assigned(FOnSelectRecord) then FOnSelectRecord(self, True, Accept);
            if accept then bookmarks.add(curBookmark);
         end
         except
      end;

      Freebookmark(bkmrk1);
     finally
      EnableControls;       { Updates display controls }
     end;

     try
      DisableControls;      { Disable them during setting of active row }

      { Maintain current row so grid doesn't jump}
      if GetActiveRow<currentRow then
      begin
         ScrollCount:= CurrentRow-GetActiveRow;
         MoveByCount:= -(GetActiveRow + ScrollCount);
         if MoveByCount<>0 then begin
            MoveBy(MoveByCount);
            SetActiveRow(CurrentRow);
         end;
      end
      else begin
         ScrollCount:= GetActiveRow-currentRow;
         MoveByCount:= ((VisibleRowCount-1)-GetActiveRow) + ScrollCount;
         If MoveByCount<>0 then begin
            MoveBy(MoveByCount);
            SetActiveRow(CurrentRow);
         end;
      end;
     finally
      EnableControls;
     end
   end;
end;

procedure TwwDBGrid.MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: integer);
var
  DrawInfo: TGridDrawInfo;
  NewSize: Integer;

  function ResizeLine(const AxisInfo: TGridAxisDrawInfo): Integer;
  var
    I: Integer;
  begin
    with AxisInfo do
    begin
      Result := 0; //FixedBoundary;
      for I := 0 to FSizingIndex - 1 do
        Inc(Result, GetExtent(I) + EffectiveLineWidth);
      Result := FSizingPos - Result;
    end;
  end;

begin
  if (dgFixedResizable in Options) and
     (FGridState = gsColSizing) and (FSizingIndex<>-1) then
  begin
//    NewSize:= 0;
    try
      CalcDrawInfo(DrawInfo);
      if UseRightToLeftAlignment then
        FSizingPos := ClientWidth - FSizingPos;
      NewSize := ResizeLine(DrawInfo.Horz);
      if NewSize > 1 then
      begin
        DrawSizingLine(DrawInfo);
        ColWidths[FSizingIndex] := NewSize;
        UpdateDesigner;
      end;
    finally
      // FGridState := gsNormal; // Done in ColWidthsChanged
      FSizingIndex:=-1;
    end
  end;
  inherited MouseUp(Button, Shift, X, Y);
end;

procedure TwwDBGrid.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: integer);
var Coord: TGridCoord;
    lookupControl: TWinControl;
    doubleClicking: boolean;
    TempShiftSelectMode: boolean;
    TempShiftSelectBookmark: TBookmark;
    DrawInfo: TGridDrawInfo;
    FIndicatorOffset: integer;
//    OrigRowOffset: integer;
begin
   { Flush data }
   Coord:= MouseCoord(x,y);
//   OrigRowOffset:= RowOffset;

   if dgIndicator in Options then FIndicatorOffset:=1 else FIndicatorOffset:=0;

   if (dgFixedResizable in Options) or (dgFixedEditable in Options) then
   begin
     CalcDrawInfo(DrawInfo);
     CalcSizingState(X, Y, FGridState, FSizingIndex, FSizingPos, FSizingOfs,
        DrawInfo);
     if FSizingIndex-FIndicatorOffset>=FixedCols then
        FSizingIndex:=-1;
   end;


   TempShiftSelectMode:= ShiftSelectMode;
   TempShiftSelectBookmark:= ShiftSelectBookmark;
   Doubleclicking:= ssDouble in shift;  { save state before calling inherited class }

   inherited MouseDown(Button, shift, x, y);


   if (dgFixedEditable in Options) and (FGridState = gsNormal) and
      (Coord.X >= FIndicatorOffset) and (Coord.Y >= FixedRows) then
   begin
      if dgEditing in Options then
      begin
        if (Coord.X = Col) and (Coord.Y = Row) then
          if dgAlwaysShowEditor in Options then
             // 9/4/01 - don't show editor if custom control or memo field
             if not isWWControl(col, row) and
	    (not isMemoField(col, row)) then ShowEditor;  { Don't show internal editor if memo field }
        Click;
      end
   end;

   if (dgFixedResizable in Options) and (FGridState = gsColSizing) and (FSizingIndex<>-1) then
   begin
      CalcDrawInfo(DrawInfo);
      CalcSizingState(X, Y, FGridState, FSizingIndex, FSizingPos, FSizingOfs,
        DrawInfo);
   end;

   if (Button = mbLeft) then begin
      update;  {Allow screen repaints to finish before continuing }

//      Coord:= MouseCoord(x,y);

      if (not CanEditGrid) and
          not (isSelectedCheckbox(Coord.x) or (dgMultiSelect in Options)) then exit;
      if not (isValidCell(Coord.x, Coord.y)) then exit;


      { 10/24/97 - Only toggle if can edit grid or multi-selection checkbox }
      if (CanEditGrid or isSelectedCheckbox(Coord.x)) then
      begin
         if doubleClicking then begin
            if not (ecoCheckboxSingleClick in EditControlOptions) then begin
               ToggleCheckBox(Coord.x, Coord.y);
               update;
            end
         end
         else begin
           if (ecoCheckboxSingleClick in EditControlOptions) then begin
               ToggleCheckBox(Coord.x, Coord.y);
               update;
            end
         end;
      end;

      { Draw combo area since mouse doesn't invalidate area if activerecord has not changed }
      if (isCustomEditCell(Coord.x, Coord.y, lookupControl) and not lookupControl.visible) then
      begin
         if (Coord.x=Col) and (Coord.y=Row) then {is Selected Cell}
            DrawCell(Coord.x, Coord.y, CellRect(Coord.x, Coord.y), [gdSelected]);
      end;

      if (dgMultiSelect in Options) and (ssShift in Shift) and TempShiftSelectMode then
      begin
         with Datalink.Dataset do begin
           if (TempShiftSelectBookmark<>nil) and BookmarkValid(TempShiftSelectBookmark) then
           begin
              SelectRecordRange(GetBookmark, TempShiftSelectBookmark);
           end
         end
      end;

     { 5/13/98 - Free shift select bookmark}
     { 8/24/99 - Don't free bookmark if ssDouble as this can cause exception if
       dataset is closed and re-opened in OnDblClick event }
      if not (ssDouble in Shift) and (TempShiftSelectBookmark <> ShiftSelectBookmark) then
         Datalink.Dataset.FreeBookmark(TempShiftSelectBookmark);

   end
end;

procedure TwwDBGrid.WMChar(var Msg: TWMChar);
var lookupControl: TWinControl;
begin
   if isMemoField(col, row) or
      isWWControl(col, row) then
   begin
      if canEditGrid and (Char(Msg.CharCode) in [^H, #32..#255]) then
      begin
         if isCustomEditCell(col, row, lookupControl) then begin
            if lookupControl.visible then
            begin
               lookupControl.setFocus;
               { lookupControl.selectAll; } { 6/30/98 - Rely on edit control to set focus }
               PostMessage(lookupControl.Handle, WM_CHAR, Word(Msg.Charcode), 0);
            end
         end;
         exit; { 6/28/99 - Used to be 2 lines down }
      end;

   end;
   inherited;
end;

procedure TwwDBGrid.CallMemoDialog;
var  memoDlg: TwwMemoDialog;
     cancel: boolean;
begin
   if (mDisableDialog in MemoAttributes) then exit;

   memoDlg:= TwwMemoDialog.create(self);
   try
      memoDlg.dataSource:= dataSource;
      memoDlg.dataField:= fieldName(col);
      memoDlg.MemoAttributes:= FMemoAttributes;
      memoDlg.Caption:= strReplaceChar(Datalink.fields[dbCol(col)].DisplayLabel, '~', ' ');
      memoDlg.Font:= font;
      memoDlg.DlgLeft:= -1; { leave as default size }

      if (not canEditGrid) or (DataLink.fields[dbCol(col)].ReadOnly) then
         memoDlg.memoAttributes:= memoDlg.memoAttributes + [mViewOnly];
      if Assigned(FOnMemoOpen) then FOnMemoOpen(self, memoDlg);
      cancel:= not memoDlg.execute;
      if Assigned(FOnMemoClose) then FOnMemoClose(self, cancel);
   finally
      memoDlg.free;
      DrawCell(col, row, CellRect(col, row), [gdSelected]);
      EditorMode := False;  {2.0}
   end;
end;

{ Override to support memo editing when F2 is entered }
procedure TwwDBGrid.KeyDown(var Key: word; Shift: TShiftState);
var wwControl: TWinControl;

  { 6/6/98 }
  procedure PlayKeystroke(Handle: HWND; VKChar: word; VKShift: Word);
  var
    KeyState: TKeyboardState;
    NewKeyState: TKeyboardState;
  begin
     GetKeyboardState(KeyState);
     NewKeyState:= KeyState;
     NewKeyState [VKShift] := $81;
     NewKeyState [VKChar] := $81;
     SetKeyboardState(NewKeyState);
     SendMessage(Handle, WM_KEYDOWN, VKChar, 1);
     SetKeyboardState(KeyState);
  end;

begin

  case Key of
    VK_DOWN:
       if isCustomEditCell(col, row, wwControl) and (ssAlt in shift) and (wwControl.visible) then
       begin
          wwControl.setFocus;
          wwPlayKeystroke(wwControl.Handle, key, VK_MENU);
          key:= 0;
          exit; // 12/11/01 - RSW - Don't pass to inherited KeyDown as then focus can get lost causing datetimepicker to not dropdown
       end
   end;

   inherited KeyDown(key, shift);
   if not DataLink.Active or not CanGridAcceptKey(key, shift) then exit;

   // Support space toggling if row-select
   if (dgRowSelect in Options) and (Key=vk_space) then
   begin
      //3/14/2002-PYW-Only SelectRecord/UnSelectRecord if multiselect enabled.
      if dgMultiSelect in Options then begin
        if isSelected then UnselectRecord
        else SelectRecord;
        exit;
      end;
   end;

   if (not isMemoField(col, row)) and (not canEditGrid) and
      (not isSelectedCheckbox(col)) then exit;

   if isCheckBox(col, row, dummy1, dummy2) then begin
      if Key = VK_SPACE then TogglecheckBox(col, row);
   end
   else if isRichEditCell(col, row, wwControl) then
   begin
      if Key <> VK_F2 then exit;
      if (wwControl=Nil) then exit;
      SendMessage(wwControl.Handle, WM_KEYDOWN, VK_F2, 0); { (wwControl as TwwDBRichEdit).execute;}
      InvalidateCell(col, row);
   end
   else if isCustomEditCell(col, row, wwControl) then begin
      if (Key = VK_F2) and (wwControl.visible) then
         wwControl.setFocus;
//      if wwControl is TwwDBCustomEdit then
      if wwControl <> nil then { 6/6/98 }
      begin
         if wwIsValidChar(Key) then
         begin
            if wwControl.visible then
            begin
               wwControl.setFocus;
               PlayKeyStroke(wwControl.Handle, key, 0); { 6/6/98}
//               InvalidateCell(col, row);
//               TwwDBCustomEdit(wwControl).KeyDown(Key, shift);  {8/22/96}
            end
         end
      end
   end
   else if isMemoField(col, row) then begin  { 12/20/96 - Move this test at the end to give customeeditor priority }
      if Key <> VK_F2 then exit;
      CallMemoDialog;
      InvalidateCell(col, row);
   end
   // 6/24/01 - Delete for inplacaeeditor should delete contents even when it does
   // not have the focus yet.
   else if CanEditGrid and (key=vk_delete) and
      (not isMemoField(col, row)) and
      (not isWWControl(col, row)) then
   begin
      ShowEditor;
      if (InplaceEditor <> nil) and InplaceEditor.visible then
         SendMessage(InplaceEditor.Handle, WM_KEYDOWN, VK_delete, 0); { (wwControl as TwwDBRichEdit).execute;}
   end;
end;

procedure TwwDBGrid.WMLButtonDblClk(var Msg:TWMLButtonDblClk);
var Coord: TGridCoord;
    col, row: integer;
    wwControl: TWinControl;
begin
   Coord:= MouseCoord(Msg.xpos, Msg.yPos);
   col:= Coord.x;
   row:= Coord.y;
   if isRichEditCell(col, row, wwControl) then begin
      inherited;
      if (wwControl<>Nil) then
         SendMessage(wwControl.Handle, WM_KEYDOWN, VK_F2, 0); { (wwControl as TwwDBRichEdit).execute;}
   end
   else if isMemoField(col, row) then
   begin
      inherited;  { Move before CallMemoDialog }
      CallMemoDialog;
   end
   else inherited;
end;

procedure TwwDBGrid.ToggleCheckBox(col, row: integer);
var
    dbColumn: integer;
    value: string;
    checkBoxOn, checkBoxOff: string;
    tempField: TField;
begin
   if not isCheckBox(col, row, checkBoxOn, checkBoxOff) then exit;

   dbColumn:= dbCol(col);
   if (DataLink.fields[dbColumn].ReadOnly) then exit;

   if (Columns[dbColumn]<>Nil) and (Columns[dbColumn].ReadOnly) then exit;

   tempField:=GetColField(dbColumn);
   if (tempField.calculated) and (lowercase(tempField.fieldName)='selected') then
   begin
      if isSelected then UnselectRecord
      else SelectRecord;
   end
   else begin
      { 9/19/97 - This code moved so that it does not execute for multi-selection checkbox }
      if (not DataSource.autoEdit) and
         (not (DataSource.state in [dsEdit, dsInsert])) then exit;

      { 4/24/00 - Don't toggle checkbox when dataset is readonly }
      if (DataLink.DataSet<>nil) and (not DataLink.dataset.canmodify) then exit;

      // 6/26/01 - Respect dgAllowInsert of False
      if (datasource<>nil) and (datasource.dataset<>nil) and
         (not (dgAllowInsert in KeyOptions)) and
        Datasource.dataset.BOF and datasource.dataset.EOF and
        (datasource.state = dsBrowse) then
      begin
         exit;
      end;

      DataLink.Edit;
      value:= GetFieldValue(dbColumn);

      { 11/11/99 - Case insensitive checkbox }
      if wwEqualStr(value, checkBoxOn) then SetFieldValue(dbColumn, checkBoxOff)
//      if value=checkBoxOn then SetFieldValue(dbColumn, checkBoxOff)
      else SetFieldValue(dbColumn, checkBoxOn);
      DrawCell(col, row, CellRect(col, row), [gdSelected]);
   end;

end;

Function TwwDBGrid.GetRowCount: integer;
begin
   result:= rowCount;
end;

Function TwwDBGrid.GetColCount: integer;
begin
   result:= colCount;
end;

Function TwwDBGrid.GetActiveRow: integer;
begin
   result:= dbRow(row);
end;

Function TwwDBGrid.GetActiveCol: integer;
begin
   result:= col;
end;

Function TwwDBGrid.GetActiveField: TField;
begin
   result:= GetColField(dbCol(Col));
end;

Procedure TwwDBGrid.SetActiveField(AFieldName: string);
var ACol: integer;
    curField: TField;
begin
   if not Datalink.Active then exit;

   for ACol:= 0 to colCount-1 do begin
      curField:= GetColField(ACol);
      if curField=Nil then continue;
      if lowercase(curField.FieldName)=lowercase(AFieldName) then begin
         SelectedIndex:= ACol;
         break;
      end
   end
end;

procedure TwwDBGrid.ColWidthsChanged;
begin
  if (dgFixedResizable in Options) and
     (FGridState = gsColSizing) and
     (FSizingIndex<inherited FixedCols) then
     FGridState := gsNormal;  // Restore state, necessary for fixed columns
  inherited ColWidthsChanged;
end;

procedure TwwDBGrid.ColumnMoved(FromIndex, ToIndex: Longint);
begin
   HideControls;
   inherited ColumnMoved(FromIndex, toIndex);
end;

constructor TwwMemoDialog.Create(AOwner: TComponent);
begin
  inherited create(AOwner);
   FDataLink := TFieldDataLink.Create;
  FMemoAttributes:= [mWordWrap, mSizeable];
  FFont:= TFont.create;
  DlgWidth:= 561;
  DlgHeight:= 396;
  DlgLeft:= 0; { center dialog }
  DlgTop:= 0;
  FLines:= TStringList.create;
end;

destructor TwwMemoDialog.Destroy;
begin
  FLines.Free;
  FDataLink.Free;
  FDataLink := nil;
  FFont.Free;
  inherited Destroy;
end;

Function TwwMemoDialog.getDataSource: TDataSource;
begin
   Result:= FdataLink.dataSource;
end;

procedure TwwMemoDialog.SetDataSource(value: TDataSource);
begin
   FDataLink.DataSource:= value;
end;

procedure TwwMemoDialog.SetDataField(value: String);
begin
   FDataLink.fieldName:= value;
end;

function TwwMemoDialog.GetDataField: string;
begin
  Result := FDataLink.FieldName;
end;

procedure TwwMemoDialog.setFont(Value: TFont);
begin
    FFont.assign(Value);
end;

procedure TwwMemoDialog.setCaption(Value: String);
begin
   FCaption:= value;
end;

function TwwMemoDialog.Execute: boolean;
begin
   result:= wwEditMemoField(Screen.ActiveForm, self, not(mViewOnly in MemoAttributes))
end;

procedure TwwMemoDialog.setwwMemoAttributes(sel : TwwMemoAttributes);
begin
     FMemoAttributes:= sel;
end;

Procedure TwwMemoDialog.DoInitDialog;
begin
  if Assigned(FOnInitDialog) then OnInitDialog(Form);
end;

Procedure TwwMemoDialog.DoCloseDialog;
begin
  if Assigned(FOnCloseDialog) then OnCloseDialog(Form);
end;

Procedure TwwDBGrid.SelectAll;
var saveBK: TBookmark;
    i: integer;
    Accept : boolean;
begin
   with DataSource.Dataset do
   begin
      If Assigned(FOnSelectAllRecords) then
      begin
         Accept:= True;
         FOnSelectAllRecords(Self, True, Accept);
         if not Accept then exit;
      end;

      for i:= 0 to SelectedList.Count-1 do  { 6/3/97 - Clear previous bookmarks }
         FreeBookmark(SelectedList.Items[i]);
      SelectedList.Clear;

      saveBK := GetBookmark;  { Save current record position }
      DisableControls;
      First;
      while (not Eof) do begin
         SelectedList.Add(GetBookmark);
         Next;
      end;
      GotoBookmark(saveBK);  { Restore original record position}
      Freebookmark(saveBK);
      EnableControls;
   end
end;

Procedure TwwDBGrid.RemoveSelected(bkmrk1, bkmrk2: TBookmark);
var i: integer;
    accept: boolean;
   Function GreaterThanOrEqual(bookmark1, bookmark2: TBookmark): boolean;
   var res: CmpBkmkRslt;
   begin
       res:= wwDataSetCompareBookmarks(DataSource.DataSet, bookmark1, bookmark2);
       if CompareBookmarksAltMethod then
          result:= integer(res)>=0
       else
         result:=
          (integer(res)=CmpGtr) or
          (integer(res)=CmpKeyEql) or
          (integer(res)=CmpEql);
   end;
begin
   with DataSource.Dataset do
   begin
      i:= 0;
      while i<=SelectedList.Count-1 do begin
         if GreaterThanOrEqual(bkmrk2, SelectedList[i]) and
            GreaterThanOrEqual(SelectedList[i], bkmrk1) then
         begin

            { 3/17/99 - Fire event }
            accept:= True;
            if Assigned(FOnSelectRecord) then FOnSelectRecord(self, False, Accept);
            if not accept then continue;

            FreeBookmark(SelectedList.Items[i]);
            SelectedList.delete(i);
         end
         else i:= i + 1;
      end;
      invalidate;
   end
end;

Procedure TwwDBGrid.UnselectAll;
var i: integer;
    Accept: boolean;
begin
   If Assigned(FOnSelectAllRecords) then
   begin
      Accept:= True;
      FOnSelectAllRecords(Self, False, Accept);
      if not Accept then exit;
   end;

   with DataSource.Dataset do
   begin
      for i:= 0 to SelectedList.Count-1 do
         FreeBookmark(SelectedList.Items[i]);
      SelectedList.Clear;
      invalidate;
   end;

   { Clear cached values }
   SelectedRecordList.clear;
   for i:= 0 to VisibleRowCount-1 do
      SelectedRecordList.add('F')

end;

Procedure TwwDBGrid.UnselectRecord;
var newBookmark: TBookmark;
    accept: boolean;
begin
    if not isSelected then exit;  { Can't unselect since its not selected 6/16/96}

    accept:= True;
    if Assigned(FOnSelectRecord) then FOnSelectRecord(self, False, Accept);
    if not accept then exit;

    newBookmark:= findBookmark;
    if newBookmark<>nil then begin
       datasource.dataset.Freebookmark(newBookmark);
       bookmarks.remove(newBookmark);
       invalidateCurrentRow;
{       for i:= 0 to colCount-1 do InvalidateCell(i, row);}
    end
end;

procedure TwwDBGrid.SortSelectedList;
var res: CmpBkmkRslt;
   Function LessThan(bookmark1, bookmark2: TBookmark): boolean;
   begin
       res:= wwDataSetCompareBookmarks(DataSource.DataSet, bookmark1, bookmark2);
       if CompareBookmarksAltMethod then
         result:= integer(res)<0
       else
         result:= integer(res)=CmpLESS;
   end;
   Function GreaterThan(bookmark1, bookmark2: TBookmark): boolean;
   begin
       res:= wwDataSetCompareBookmarks(DataSource.DataSet, bookmark1, bookmark2);
       if CompareBookmarksAltMethod then
         result:= integer(res)>0
       else
         result:= integer(res)=CmpGtr;
   end;

   procedure Partition(var i, j: integer);
   var Pivot, Temp: TBookmark;
   begin
      Pivot:= bookmarks[(i+j) div 2];
      repeat
         while LessThan(bookmarks[i], Pivot) do i:= i + 1;
         while GreaterThan(bookmarks[j], Pivot) do j:= j - 1;
         if (i<=j) then begin
            Temp:= bookmarks[i];
            bookmarks[i]:= bookmarks[j];
            bookmarks[j]:= Temp;
            i:= i +1;
            j:= j-1;
         end
      until (i>j);
   end;

   procedure QuickSort(m, n: integer);
   var i,j: integer;
   begin
      if (m<n) then begin
         i:= m; j:= n;
         Partition(i, j);
         QuickSort(m,j);
         QuickSort(i,n);
      end
   end;
begin
    QuickSort(0, bookmarks.count-1);
end;

Procedure TwwDBGrid.SelectRecord;
var newBookmark: TBookmark;
    accept: boolean;

  procedure UpdateGrid;
  var j: integer;
  begin
     for j:= 0 to colCount-1 do InvalidateCell(j, row);
  end;

begin
   { 6/2/97 - Update starting shift-select record }
   if ShiftSelectMode then
   begin
      Datasource.dataset.checkBrowseMode;
      ShiftSelectBookmark:= DataSource.DataSet.GetBookmark;
   end;

   datasource.dataset.checkBrowseMode; {6/8/97 - Moved before isSelected - bookmarks don't work in edit mode}
   RefreshbookmarkList;   { 6/8/97 - Refresh before calling isSelected }

   if isSelected then exit; { Don't add if already in list 6/16/96}

   accept:= True;
   if Assigned(FOnSelectRecord) then FOnSelectRecord(self, True, Accept);
   if not accept then exit;

   newBookmark:= findBookmark;
   if newBookmark=Nil then
      newBookmark:= datasource.dataset.getBookmark;

   if (newBookmark<>nil) then bookmarks.add(newBookmark);  { 2/13/97 - Check for nil bookmark}
   InvalidateCurrentRow;

end;

Function TwwDBGrid.IsSelectedRecord: boolean;
var i: integer;
    curBookmark: Tbookmark;
    thisTable: TDataset;
    res: CmpBkmkRslt;
begin
   thisTable:= datasource.dataset;
   if (thisTable.state=dsEdit) or (thisTable.state=dsInsert) then begin
      result:= False;
      exit;
   end;

   curBookmark:= thisTable.getBookmark;

   result:= False;
   if curBookmark=Nil then exit;

   for i:= 0 to bookmarks.count-1 do begin
      res:= wwDataSetCompareBookmarks(DataSource.DataSet, bookmarks.items[i], curBookmark);
      if CompareBookmarksAltMethod then
      begin
         if (res=0) then
         begin
            result:= True;
            break;
         end
      end
      else if (res=CMPKeyEql) or (res=CMPEql) then begin
         result:= True;
         break;
      end
   end;

   thisTable.freebookmark(curBookmark); { Don't use finally block - too slow }

end;

procedure TwwDBGrid.RefreshBookmarkList;
var i, OldActive: integer;
begin
   SelectedRecordList.clear;
   if bookmarks.count>0 then begin
      OldActive:= 0; {Make compiler happy}
      try
         OldActive:= DataLink.ActiveRecord;
         for i:= 0 to VisibleRowCount-1+RowOffset do begin
            DataLink.ActiveRecord:= i;
            if isSelectedRecord then
               SelectedRecordList.add('T')
            else SelectedRecordList.add('F');
         end;
         DataLink.ActiveRecord:= OldActive;
      except
         DataLink.ActiveRecord:= OldActive;
      end
   end
   else begin
      for i:= 0 to VisibleRowCount-1 do begin
         SelectedRecordList.add('F')
      end;
   end
end;

Function TwwDBGrid.IsSelected: boolean;
begin
   result:= IsSelectedRow(DataLink.ActiveRecord);
{   if (DataLink.ActiveRecord>=0) and (DataLink.ActiveRecord<SelectedRecordList.count) then
     result:= SelectedRecordList.strings[DataLink.ActiveRecord]='T'
   else result:= False;}
end;

Function TwwDBGrid.IsSelectedRow(DataRow: integer): boolean;
begin
   if (DataRow>=0) and (DataRow+RowOffset<SelectedRecordList.count) then
     result:= SelectedRecordList.strings[DataRow+RowOffset]='T'
   else result:= False;
end;

Function TwwDBGrid.FindBookmark: TBookmark;
var i: integer;
    curBookmark: Tbookmark;
    thisTable: TDataset;
    res: CmpBkmkRslt;
begin
   result:= Nil;
   thisTable:= datasource.dataset;
   curBookmark:= thisTable.getBookmark;
   if curBookmark=nil then exit;  {2/13/97 }

   try
      for i:= 0 to bookmarks.count-1 do begin
          res:= wwDataSetCompareBookmarks(DataSource.DataSet, bookmarks.items[i], curBookmark);
          if CompareBookmarksAltMethod then
          begin
             if res=0 then
             begin
                result:= bookmarks.items[i];
                exit;
             end
          end
          else if (res=CMPKeyEql) or (res=CMPEql) then begin
             result:= bookmarks.items[i];
             exit;
          end
      end;
   finally
      thisTable.freebookmark(curBookmark);
   end;
end;

Function TwwDBGrid.GetFieldValue(ACol: integer): string;
const MaxMemoSize = 255;
var
  Field: TField;
  Buffer: array[0..MaxMemoSize] of char;
  wwControl: TWinControl;
  rpc:TRichProtectClass;
  URLDisplay, LinkAddress: string;

  Function HandleSpecialCharacters(tempResult: string; numRead: Longint): string;
  var curpos: integer;
      result1, result2: string;
  begin
     setLength(tempResult, numRead);

     if dgWordWrap in Options then
     begin
        result:= tempResult;
        exit;
     end;

     curpos:= 1;
     result1:= strGetToken(tempResult, #13, curpos);
     curpos:= 1;
     result2:= strGetToken(tempResult, #10, curpos);
     if length(result1)<length(result2) then result:= result1
     else result:= result2;
  end;

  {9/2/97 - Override isCustomEditCell so that it ignores record-view when mapping}
  function IsCustomEditCell(
        col, row: integer;
        var customEdit: TWinControl) : boolean;
  var fldName: string;
      i, apos: integer;
      controlType : TStrings;
  begin
     result:= False;
     if ecoDisableCustomControls in EditControlOptions then exit;
     if not isValidCell(col, row) then exit;
     fldName:= DataLink.fields[dbCol(col)].fieldName;

     { 8/14/97 - Optimized logic to speed painting of grid }
     ControlType:= GetControlType;
     for i:= 0 to ControlType.count-1 do begin
        APos:= 1;
        if strGetToken(controlType[i], ';', APos)<>fldName then continue;
        if isWWEditControl(strGetToken(controlType[i], ';', APos)) then
        begin
           customEdit:= GetComponent(strGetToken(controlType[i], ';', APos));
           if customEdit=Nil then break;
  	   result:= True;
           break;
        end
     end;
  end;

  function HasRichEditContents: boolean;
  var
    BlobStream: TStream;
    Buffer: packed array[1..5] of char;
  begin
    BlobStream:= Nil;
    try
      result:= False;
      BlobStream := Field.DataSet.CreateBlobStream(Field, bmRead);
      Buffer:= '     ';
      BlobStream.Read(Buffer, 5);
      result:= Buffer = '{\rtf'
    finally
      BlobStream.Free;
    end;
  end;

begin
  Result := '';
  Field := GetColField(ACol);
  if Field <> nil then begin
     if (Field is TBlobField) and  {8/12/97 - Optmization }
        isRichEditCell(ACol+XIndicatorOffset, 1, wwControl) then
     begin
         if tempRichEdit=Nil then begin
            tempRichEdit:= TwwDBRichEdit.create(self);
            tempRichEdit.visible:= False;
            tempRichEdit.parent:= self;
            tempRichEdit.borderStyle:= bsNone;
            if csDesigning in ComponentState then {otherwise shows up at design time }
               ShowWindow(tempRichEdit.handle, sw_hide);
         end;

         rpc:=TRichProtectClass.Create;
                         {1/28/97 - Allow Change of text when protected flag in richtext}
         tempRichEdit.OnProtectChange:= rpc.RichProtectChange;
         if HasRichEditContents then
         begin
            if LoadAllRTF then
               tempRichEdit.CopyRichEditFromBlob(Field)
            else
               tempRichEdit.LoadBlobStart(Field) {10/6/98 }
         end
         else tempRichEdit.Lines.Assign(Field);
         tempRichEdit.OnProtectChange:= Nil;
         rpc.Free;
//         PaintRichEdit;
         result:= tempRichEdit.Text;

{         if Datalink.ActiveRecord>=0 then
            result:= String(RichEditBufferList[Datalink.ActiveRecord]);}
     end
     else if (Field.DataType in [ftMemo, ftOraClob]) then begin
//        if (Field.DataType = ftMemo) then begin

        { Don't display memo if no record }
        if (DataSource.DataSet.Bof and DataSource.dataSet.eof) and
           not (DataSource.DataSet.State = dsInsert) then
        begin
           result:= '';
           exit;
        end;

        if mGridShow in FMemoAttributes then begin
           try
              if (getActiveRow=DataLink.ActiveRecord+RowOffset) then
              begin
                 field.dataset.updateCursorPos;
                 Result:= TMemoField(field).asString;
              end
              else begin
                 Result:= TMemoField(field).asString;
              end

           except
              strcopy(buffer, '(Memo)');
              result:= strPas(buffer);
           end
        end
        else begin
           strcopy(buffer, '(Memo)');
           result:= strPas(buffer);
        end
     end
     else begin
        if TwwCacheColInfoItem(FCacheColInfo[ACol+FIndicatorOffset]).ControlType = 'URL-Link' then
        begin
           GetURLLink(Field.asString,
                      URLDisplay, LinkAddress);
           result:= URLDisplay;
        end
        else if (isCustomEditCell(ACol+xIndicatorOffset, 1, wwControl)) then
        begin
            if (wwControl is TwwDBCustomEdit) then
            begin
               if not TwwDBCustomEdit(wwControl).GetFieldMapText(Field.asString, Result) then
                  Result:= Field.DisplayText
               else FieldMappedText:= True;
            end
            else if (wwControl is TwwRadioGroup) then
            begin
               Result:= TwwRadioGroup(wwControl).GetDisplayValue(Field.asString)
            end
            else Result := Field.DisplayText;
        end
        else Result := Field.DisplayText;
     end
  end
end;

{ Set focus to this grid when changing records }
{ If focus is on currentCustomEdit then lookupcombo does not properly move }
procedure TwwDBGrid.Scroll(Distance: Integer);
begin
  if visible and (currentCustomEdit<>Nil) and
     (currentCustomEdit.visible) and currentCustomEdit.focused then
     { 1/9/98 - Only set focus if canFocus is true }
     if CanFocus then setFocus;
  inherited Scroll(Distance);

end;

procedure TwwDBGrid.SaveToIniFile;
var TempCount,i:Integer;
    parts:TStringList;
    tempField:TField;
    tempreadonly : String;
    tempgroupname: String;
    IniFile:TIniFile;
    RegFile:TRegIniFile;
    Dir:String;
begin
   if (csDesigning in ComponentState) then exit;
   if IniAttributes.SaveToRegistry and (IniAttributes.FileName = '') then begin
      if not (csDestroying in ComponentState) then
         MessageDlg('FileName required when saving to registry',mtWarning,[mbok],0);
      exit;
   end;

   if (not IniAttributes.SaveToRegistry) and (IniAttributes.FileName <> '') then
   begin
      dir := ExtractFilePath(IniAttributes.FileName);
      if (dir <> '') and not DirectoryExists(dir) then begin
         if not (csDestroying in ComponentState) then MessageDlg('Directory does not exist',mtWarning,[mbOk],0);
         exit;
      end;
   end;

   if IniAttributes.Delimiter = '' then begin
      MessageDlg('Key delimiter required',mtWarning,[mbok],0);
      exit;
   end;

   IniFile := nil;
   RegFile := nil;

   if useTFields then begin
      TempCount:= FieldCount;
      parts:= nil; { Make compiler happy }
   end
   else begin
      TempCount:= Selected.Count;
      parts := TStringList.create;
   end;

   if IniAttributes.SaveToRegistry then
      Regfile := TRegInifile.Create(IniAttributes.FileName)
   else Inifile := TInifile.Create(IniAttributes.FileName);

   try
     if (IniAttributes.SaveToRegistry and (RegFile = nil)) or
        ((not IniAttributes.SaveToRegistry) and (IniFile = nil)) then
     begin
       exit;
     end;

     if (TempCount > 0) then
        if IniAttributes.SaveToRegistry then
        begin
           Regfile.EraseSection(IniAttributes.SectionName);
        end
        else begin  // 4/15/01 - Don't throw exception
//           Inifile.EraseSection(IniAttributes.SectionName)
           if not WritePrivateProfileString(PChar(IniAttributes.SectionName), nil, nil,
               PChar(IniAttributes.FileName)) then exit
        end;

     for i := 0 to TempCount - 1 do
     begin
        tempField:= nil; { Make compiler happy}
        if useTFields then
           tempField:= Fields[i]
        else begin  //9/30/99 - Remove dependency on Fields
           strBreakApart(selected[i], #9, parts);
        end;

        with IniAttributes do
          if useTFields then begin
            if tempField.ReadOnly or (fields[i].ReadOnly) or
               (Columns[i]<>Nil) and (Columns[i].ReadOnly) then
               begin
                 if SaveToRegistry then
                 Regfile.WriteString(SectionName,tempField.FieldName,
                    IntToStr(tempField.DisplayWidth)+Delimiter+
                    tempField.DisplayLabel+Delimiter+'T')
                 else Inifile.WriteString(SectionName,tempField.FieldName,
                    IntToStr(tempField.DisplayWidth)+Delimiter+
                    tempField.DisplayLabel+Delimiter+'T');
               end
            else begin
               if SaveToRegistry then
                  Regfile.WriteString(SectionName,tempField.FieldName,
                    IntToStr(tempField.DisplayWidth)+Delimiter+tempField.DisplayLabel+Delimiter+'F')
               else
                  Inifile.WriteString(SectionName,tempField.FieldName,
                    IntToStr(tempField.DisplayWidth)+Delimiter+tempField.DisplayLabel+Delimiter+'F');
            end;
          end
          else begin //9/30/99 - Remove dependency on Fields and Columns
            //6/13/2001-PYW- Support GroupName.
            tempgroupname := '';
            if (parts.count >= 4) then begin
              if parts.count = 5 then tempgroupname := parts[4];
              tempreadonly := parts[3];
            end
            else tempreadonly := 'F';

            if SaveToRegistry then begin
               if tempgroupname = '' then
                  Regfile.WriteString(SectionName,parts[0],parts[1]+Delimiter+parts[2]+Delimiter+tempreadonly)
               else Regfile.WriteString(SectionName,parts[0],parts[1]+Delimiter+parts[2]+Delimiter+tempreadonly+Delimiter+tempgroupName);
            end
            else begin
               if tempgroupname = '' then
                  Inifile.WriteString(SectionName,parts[0],parts[1]+Delimiter+parts[2]+Delimiter+tempreadonly)
               else Inifile.WriteString(SectionName,parts[0],parts[1]+Delimiter+parts[2]+Delimiter+tempreadonly+Delimiter+tempgroupName);
            end
          end;
     end;
//     MyInifile.UpdateFile;
  finally
     if IniFile <> nil then IniFile.Free;
     if RegFile <> nil then RegFile.Free;
     if (not useTFields) and (parts <> nil) then parts.Free;
  end;
end;

procedure TwwDBGrid.LoadFromIniFile;
var TmpIni: TIniFile;
    TmpReg:TRegIniFile;
    SectionValues:TStringList;
    KeyValue,dir:String;
    i:integer;
    tempSelected:TStringList;

  Function ReplaceStrWithStr(str: string; removestr: string;replaceStr: string): string;
  var i: integer;
  begin
     Result := '';
     i:=1;
     while i<=length(str) do begin
        if (strlcomp(PChar(Copy(str,i,length(removestr))), PChar(removestr),
            length(removestr))<>0) then
        begin
           Result := Result + str[i];
           i:=i+1;
        end
        else begin
          Result:= Result + replaceStr;
          i:=i+length(removeStr);
        end;
     end;
  end;

  { 3/6/00 - Add new fields to dynamic selected property from selected property generated by iniattributes }
  procedure AddNewFields;
  var i, j, apos: integer;
      OrigFieldName, NewFieldName: string;
      AlreadyFound: boolean;
  begin
    if not IniAttributes.CheckNewFields then exit;
    for i:= 0 to tempSelected.count-1 do begin
      APos:= 1;
      OrigFieldName:= strGetToken(TempSelected[i], #9, apos);
      AlreadyFound:= false;
      for j:= 0 to Selected.count-1 do begin
         APos:= 1;
         NewFieldName:= strGetToken(Selected[j], #9, apos);
         if wwEqualStr(OrigFieldName, NewFieldName) then AlreadyFound:= true;
      end;
      if not AlreadyFound then Selected.Add(tempSelected[i]);
    end
  end;

begin
   if csDesigning in ComponentState then exit;

   OrigSelected.assign(Selected);

   if IniAttributes.SaveToRegistry and (IniAttributes.FileName = '') then begin
      MessageDlg('FileName required when saving to registry',mtWarning,[mbok],0);
      exit;
   end;

   if IniAttributes.Delimiter = '' then begin
      MessageDlg('Key delimiter required',mtWarning,[mbok],0);
      exit;
   end;

   if (not IniAttributes.SaveToRegistry) and (IniAttributes.FileName <> '') then
   begin
      dir := ExtractFilePath(IniAttributes.FileName);
      if (dir <> '') and not DirectoryExists(dir) then begin
         MessageDlg('Directory does not exist',mtWarning,[mbOk],0);
         exit;
      end;
   end;

   TmpIni := nil;
   TmpReg := nil;

   tempSelected := TStringList.Create;
   tempSelected.Assign(Selected);

   if IniAttributes.SaveToRegistry then
   begin
      TmpReg := TRegInifile.Create(IniAttributes.FileName)
   end
   else TmpIni := TInifile.Create(IniAttributes.FileName);

   try
     if (IniAttributes.SaveToRegistry and (TmpReg = nil)) or
        ((not IniAttributes.SaveToRegistry) and (TmpIni = nil)) then
     begin
       exit;
     end;

     SectionValues := TStringList.Create;
     try
       if IniAttributes.SaveToRegistry then
       begin
          TmpReg.ReadSectionValues(IniAttributes.SectionName, SectionValues)
       end
       else
          TmpIni.ReadSectionValues(IniAttributes.SectionName, SectionValues);

       if SectionValues.Count = 0 then exit;
       Selected.Clear;
       for i:= 0 to SectionValues.count-1 do begin
         KeyValue := SectionValues.Values[SectionValues.Names[i]];
         if AnsiPos(IniAttributes.Delimiter,KeyValue) > 0 then
            Selected.Add(SectionValues.Names[i]+#9+
               ReplaceStrWithStr(KeyValue,IniAttributes.Delimiter,#9))
         else begin
            MessageDlg('Key Delimiter Not Found',mtWarning,[mbok],0);
            Selected.Clear;
            if not UseTFields then Selected.Assign(tempSelected);
            exit;
         end;
       end;
       AddNewFields;
       ApplySelected;
     finally
       SectionValues.Free;
     end;
   finally
      if IniAttributes.SaveToRegistry then TmpReg.Free
      else TmpIni.Free;
      tempSelected.Free;
   end;

end;

procedure TwwDBGrid.Loaded;
var form: TCustomForm;
begin
   //Initialize the FormName property here now that the parent has been assigned.
   form:= GetParentForm(self) as TCustomForm; { 10/10/99 Check for nil parent form}
   if form<>nil then IniAttributes.FFormName := form.name;

   inherited loaded;
   GridIsLoaded:= True;
   if not DoneInitControls then RefreshDisplay;
end;

Procedure TwwDBGrid.AddDependent(value: TComponent);
begin
   FDependentComponents.add(value);
end;

Procedure TwwDBGrid.RemoveDependent(value: TComponent);
begin
   FDependentComponents.remove(value);
end;

Procedure TwwDBGrid.SetActiveRow(val: integer); {10/24/96 }
begin
   if dgTitles in Options then row:= val+1
   else row:= val;
   DataLink.ActiveRecord:= val+RowOffset;
   invalidate;
end;


procedure TwwDBGrid.ColEnter;
begin
   RefreshActiveControl;
//   inherited UpdateCustomEdit;
   inherited ColEnter;
end;

procedure TwwDBGrid.RefreshActiveControl;
var CustomEdit: TWinControl;
    DBColumn :integer;
  procedure UpdateCustomEdit;
  begin
      if customEdit.parent<>self then customEdit.parent:= self;
      if wwGetControlDataSource(customEdit)<>datasource then
         wwSetControlDataSource(customEdit, dataSource);
      if not wwEqualStr(wwGetControlDataField(customEdit), GetActiveField.FieldName) then
         wwSetControlDataField(customEdit, GetActiveField.FieldName);
      TEdit(customEdit).Ctl3d:= False;
      if not wwIsClass(CustomEdit.classType, 'TwwDataInspector') then
         TEdit(customEdit).BorderStyle:= bsNone;

      // Don't support scrollbars for inspector as then text gets cutoff in csPaintCopyState
      // If find way to support csPaintCopy, then we can remove this restriction
      if wwIsClass(CustomEdit.classtype, 'TwwDataInspector') then
         TDrawGrid(CustomEdit).ScrollBars:= ssNone;

      // 5/18/01 - Updates currentcustomedit, and currentcustomedit position
// code causes problem in normal expand operation when clicking on different row
// and different column
      inherited UpdateCustomEdit;

  end;
begin
   if (csDesigning in ComponentState) then exit;
   if (dgRowSelect in Options) then exit;

   if isCustomEditCell(Col, Row, customEdit) and
      (customEdit<>FDateTimePicker) and { 2/19/99 - Default datetimepicker should go through default datetimepicker specfic code}
      (ShouldShowCustomControls or (customEdit is TwwExpandButton)) then
//      (not (ecoDisableCustomControls in EditControlOptions)) and
//      (canEditGrid or AlwaysShowControls) then
   begin
      UpdateCustomEdit;
   end
   else begin
      if (not (ecoDisableDateTimePicker in EditControlOptions)) and
         (GetActiveField is TDateTimeField) then begin
         if FDateTimePicker=Nil then
         begin
            FDateTimePicker:= CreateDateTimePicker;
            DoCreateDateTimePicker(FDateTimePicker);
         end;
         customEdit:= FDateTimePicker;

         { 11/26/98 - Respect readonly property of related field }
         dbColumn:= dbCol(col);
         FDateTimePicker.ReadOnly:=
            (DataLink.fields[dbColumn].ReadOnly) or
            (Columns[dbColumn]<>Nil) and (Columns[dbColumn].ReadOnly);

         customEdit.visible:= False;
         UpdateCustomEdit;

         // Force handle of custom control to be created as we are going to call perform
         if not customEdit.HandleAllocated then
            customEdit.HandleNeeded; //showmessage('');

         customEdit.Perform(wm_size, SIZE_RESTORED, 0); { Forces SetEditRect to be called }
      end
   end;

//   inherited ColEnter; { 3/9/00 - should not colenter in this routine }
end;

procedure TwwDBGrid.CreateWnd;
begin
  inherited CreateWnd;
  if FDirtyIni then  //9/30/99 - Added LoadfromIniFile after form create.
  begin
     if IniAttributes.Enabled then
        LoadFromIniFile;
     FDirtyIni := False;
  end;
end;

procedure TwwDBGrid.CalcRowHeight;
{var
    i: Integer;
    SaveDataLink: integer;
    TotalRowHeight: integer;
    OldActiveRecord, NewActiveRecord, ShiftAmount: integer;}
begin
   inherited CalcRowHeight;

(*   if dgVariableRowHeight in Options then
   begin
     if DataLink.Active then begin
       TotalRowHeight:= RowHeights[0];
       HideEditor;
       UpdateRowCount;
//       RowCount:= CalcVariableRowCount;
//       DataLink.BufferCount := VisibleRowCount;
//       UpdateRowCount;

       OldActiveRecord:= DataLink.ActiveRecord;
       NewActiveRecord:= VDataLink.ActiveRecord;
       ShiftAmount:= NewActiveRecord-OldActiveRecord;

       // Increase buffercount so that later rows can be checked.
{       FVDataLink.BufferCount:=
          FVDataLink.BufferCount + ShiftAmount;
       NewActiveRecord:= FVDataLink.ActiveRecord;
       ShiftAmount:= NewActiveRecord-OldActiveRecord;
}
       for i:= 0 to VDataLink.RecordCount-1 do begin
         VDataLink.ActiveRecord:= i+ShiftAmount;
         if odd(datasource.dataset.fieldbyname('customer no').asinteger) then
            RowHeights[i+1]:= 15 + 2
         else
            RowHeights[i+1]:= 45 + 2;

         if odd(datasource.dataset.fieldbyname('customer no').asinteger) then
            TotalRowHeight:= TotalRowHeight + 15 + 2
         else
            TotalRowHeight:= TotalRowHeight + 45 + 2;
         if TotalRowHeight>ClientHeight then break;
         if i+ShiftAmount>=VDataLink.RecordCount then break;
       end;
       VDataLink.ActiveRecord:= NewActiveRecord;

{
       SaveDataLink:= DataLink.ActiveRecord;
       for i:= FTopRecord to DataLink.RecordCount-1 do begin
         DataLink.ActiveRecord:= i;
         if odd(datasource.dataset.fieldbyname('customer no').asinteger) then
            RowHeights[i+1]:= 15 + 2
         else
            RowHeights[i+1]:= 45 + 2;

         if odd(datasource.dataset.fieldbyname('customer no').asinteger) then
            TotalRowHeight:= TotalRowHeight + 15 + 2
         else
            TotalRowHeight:= TotalRowHeight + 45 + 2;
         if TotalRowHeight>ClientHeight then break;

       end;
       DataLink.ActiveRecord:= SaveDataLink;
}
     end
   end;
*)
end;

procedure TwwDBGrid.FlushChanges;
begin
   inherited FlushChanges;
   if (CurrentCustomEdit<>Nil) and (CurrentCustomEdit.visible) then
      CurrentCustomEdit.Perform(CM_Exit,0,0);
end;


{** Screen painting optimizations - Call GetCustomEdit for faster lookups to control cache }
{   Define ControlCacheField as TStringList and ControlCache as TList }
{procedure TwwDBGrid.GetCustomEdit(FlName: string; var customEdit: TCustomEdit): boolean;
var i: integer;
begin
   for i:= 0 to ControlCacheField.count-1 do begin
      if FldName=ControlCacheField[i] then
      begin
         customEdit:= TCustomEdit(ControlCache[i]);
         if customEdit=Nil then break;
	 result:= True;
	 break;
      end
   end;
end;

procedure TwwDBGrid.RefreshControlCache;
var apos, i: integer;
    customEdit: TCustomEdit;
    ControlType: TStrings;
    FieldName: string;
begin
   ControlCache.clear;
   ControlCacheField.clear;
   controlType:= wwGetControlType(datasource.dataset);
   for i:= 0 to ControlType.count-1 do begin
      APos:= 1;
      FieldName:= strGetToken(controlType[i], ';', APos);
      if isWWEditControl(strGetToken(controlType[i], ';', APos)) then
      begin
         customEdit:= GetComponent(strGetToken(controlType[i], ';', APos));
         if wwisClass(GetParentForm(customEdit).classType, 'TwwRecordViewForm') then continue;
         if customEdit<>Nil then begin
           ControlCache.add(customEdit);
           ControlCacheField.add(FieldName);
         end
      end
   end
end;
}

{1/28/97 - Allow Change of text when protected flag in richtext}
procedure TRichProtectClass.RichProtectChange(Sender: TObject; StartPos,
  EndPos: Integer; var AllowChange: Boolean);
begin
   AllowChange:= True;
end;

(*
procedure TwwDBGrid.PaintWindow(DC: HDC);
var rpc: TRichProtectClass;
    priorActiveRecord, i: integer;
begin
    if tempRichEdit=Nil then begin
      tempRichEdit:= TRichEdit.create(self);
      tempRichEdit.visible:= False;
      tempRichEdit.parent:= self;
      if csDesigning in ComponentState then {otherwise shows up at design time }
          ShowWindow(tempRichEdit.handle, sw_hide);
    end;

    RichEditBufferList.Clear;
    PriorActiveRecord:= Datalink.ActiveRecord;
    for i:= 0 to VisibleRowCount-1 do begin
       DataLink.ActiveRecord:= i;
       rpc:=TRichProtectClass.Create;
       tempRichEdit.OnProtectChange:= rpc.RichProtectChange;
       tempRichEdit.Lines.Assign(Fields[1]);
       tempRichEdit.OnProtectChange:= Nil;
       RichEditBufferList.Add(tempRichEdit.text);
       rpc.Free;
    end;
    Datalink.ActiveRecord:= PriorActiveRecord;

   inherited PaintWindow(DC);
end;
*)
procedure TwwDBGrid.GetControlInfo(AFieldName: string;
    var AControlType: string; var AParameters: string);
begin
   inherited;
   if (ecoDisableCustomControls in EditControlOptions) and
      isWWEditControl(AControlType) then AControlType:= '';
end;

procedure TwwDBGrid.DoCreateDateTimePicker(ADateTimePicker: TwwDBCustomDateTimePicker);
begin
   if Assigned(FOnCreateDateTimePicker) then
      FOnCreateDateTimePicker(self, FDateTimePicker);
end;

function TwwDBGrid.GetDateTimePicker: TwwDBCustomDateTimePicker;
begin
   if FDateTimePicker=nil then
   begin
      FDateTimePicker:= CreateDateTimePicker;
      DoCreateDateTimePicker(FDateTimePicker);
   end;
   Result:= FDateTimePicker;
end;

function TwwDBGrid.CreateDateTimePicker: TwwDBCustomDateTimePicker;
begin
   result:= TwwDBDateTimePicker.create(self);
end;

procedure TwwMemoDialog.SetLines(val: TStrings);
begin
   if FLines<>val then
      FLines.assign(val);
end;

procedure TwwIniAttributes.SetFileName(val: string);
begin
   if val <> FFileName then begin
      FFileName:= val;
   end;
end;

procedure TwwIniAttributes.SetSectionName(val: string);
begin
   if val <> FSectionName then begin
      FSectionName:= val;
   end;
end;

function TwwIniAttributes.GetSectionName: string;
begin
   if FSectionName = '' then begin
      if not (csDesigning in Owner.ComponentState) then
         result := FFormName+Owner.Name;
   end
   else result := FSectionName;
end;

function TwwIniAttributes.GetFileName: string;
begin
   if (FFileName = '') and wwInternational.connected then begin
      result := wwInternational.IniFileName;
      if not FSaveToRegistry then
         if (result = '') and not (csDesigning in Owner.ComponentState) then
            result := wwExtractFileNameOnly(Application.ExeName)+'.ini'
   end
   else result := FFileName;
end;

procedure TwwIniAttributes.SetEnabled(val: boolean);
begin
   if val <> FEnabled then begin
      FEnabled:= val;
//      NotifyOwnerWindow(Owner);
   end;
end;

procedure TwwIniAttributes.SetDelimiter(val: string);
begin
   if val <> FDelimiter then begin
      FDelimiter:= val;
//      NotifyOwnerWindow(Owner);
   end;
end;

procedure TwwDBGrid.CalcSizingState(X, Y: Integer; var State: TGridState;
  var Index: Longint; var SizingPos, SizingOfs: Integer;
  var FixedInfo: TGridDrawInfo);
var
  SkipInherited: boolean;

  function XOutsideHorzFixedBoundary: Boolean;
  begin
    with FixedInfo do
      if not UseRightToLeftAlignment then
        Result := X > Horz.FixedBoundary+3
      else
        Result := X < ClientWidth - Horz.FixedBoundary;
  //  result:= True;
  end;

  function XOutsideOrEqualHorzFixedBoundary: Boolean;
  begin
    with FixedInfo do
      if not UseRightToLeftAlignment then
        Result := X >= Horz.FixedBoundary
      else
        Result := X <= ClientWidth - Horz.FixedBoundary;
  end;

  procedure CalcAxisState(const AxisInfo: TGridAxisDrawInfo; Pos: Integer;
    NewState: TGridState);
  var
    I, Line, Back, Range: Integer;
    FIndicatorOffset: integer;
    IndicatorWidth:integer;
  begin
    if UseRightToLeftAlignment then
      Pos := ClientWidth - Pos;
    with AxisInfo do
    begin
      Line := 0; //FixedBoundary;
      Range := EffectiveLineWidth;
      Back := 0;
      if Range < 7 then
      begin
        Range := 7;
        Back := (Range - EffectiveLineWidth) shr 1;
      end;
      FIndicatorOffset := 0;
      if dgIndicator in Options then FIndicatorOffset := 1;
      for I := 0 to GridCellCount - 1 do
      begin
        Inc(Line, GetExtent(I));
        if Line > GridBoundary then Break;
        if (Pos >= Line - Back) and (Pos <= Line - Back + Range) and
           (i>=FIndicatorOffset) then
        begin
          State := NewState;
          SizingPos := Line;
          SizingOfs := Line - Pos;
          Index := I;
          SkipInherited:= True;
          Exit;
        end;
        Inc(Line, EffectiveLineWidth);
      end;
      // 5/8/2002- Handle border case for FixedCols when it is sized wider than grid.
      if (GridBoundary = GridExtent) and (Pos >= GridExtent - Back)
        and (Pos <= GridExtent) then
      begin
        State := NewState;
        SizingPos := GridExtent;
        SizingOfs := GridExtent - Pos;
        //5/8/2002 - Check to see if we are in fixed area.
        if not XOutsideOrEqualHorzFixedBoundary then
        begin
          Indicatorwidth := FIndicatorOffset*ColWidthsPixels[0];
          //5/8/2002 - Handle case where 1st fixed column fills grid
          if (Indicatorwidth + ColWidthsPixels[FIndicatorOffset]) > GridBoundary then
          begin
             Index := 1;
          end
          else Index := LastFullVisibleCell-1
        end
        else begin
           //5/8/2002 - Handle case where 1st fixed column fills grid
           if FixedBoundary = FullVisBoundary then
              Index := LastFullVisibleCell
           else
              Index := LastFullVisibleCell+1;
        end;
        SkipInherited:= True;
      end;
    end;
  end;

begin
  // 5/8/2002 - Due to TCustomGrid bugs always do the code below.
{  if not (dgFixedResizable in Options) then begin
     inherited;
     exit;
  end;}

  State := gsNormal;
  Index := -1;
  SkipInherited:= False;
  if dgColumnResize in Options then begin
    with FixedInfo do
    begin
      Vert.GridExtent := ClientHeight;
      Horz.GridExtent := ClientWidth;
      // 5/8/2002 - If not fixedresizable check only call if X is not in fixed area.

      // 9/4/2002 - RSW - Only override for fixed columns
      if (dgFixedResizable in Options) and (not XOutsideHorzFixedBoundary) then
      begin
        if Y >= Vert.FixedBoundary then Exit;
        CalcAxisState(Horz, X, gsColSizing);
      end
    end;
  end;
  if not SkipInherited then inherited;
end;

procedure TwwDBGrid.DrawSizingLine(const DrawInfo: TGridDrawInfo);
var
  OldPen: TPen;
begin
  OldPen := TPen.Create;
  try
    with Canvas, DrawInfo do
    begin
      OldPen.Assign(Pen);
      Pen.Style := psDot;
      Pen.Mode := pmXor;
      Pen.Width := 1;
      try
        if FGridState = gsRowSizing then
        begin
          MoveTo(0, FSizingPos);
          LineTo(Horz.GridBoundary, FSizingPos);
        end
        else
        begin
          MoveTo(FSizingPos, 0);
          LineTo(FSizingPos, Vert.GridBoundary);
        end;
      finally
        Pen := OldPen;    
      end;
    end;
  finally
    OldPen.Free;
  end;
end;

procedure TwwDBGrid.MouseMove(Shift: TShiftState; X, Y: Integer);
var
  DrawInfo: TGridDrawInfo;
  NewSize: integer;
//  OldCaptionWidth: integer;

  function ResizeLine(const AxisInfo: TGridAxisDrawInfo): Integer;
  var
    I: Integer;
  begin
    with AxisInfo do
    begin
      Result := 0;
      for I := 0 to FSizingIndex - 1 do
        Inc(Result, GetExtent(I) + EffectiveLineWidth);
      Result := FSizingPos - Result;
    end;
  end;

begin
  if (dgFixedResizable in Options) and
     (FGridState = gsColSizing) and (FSizingIndex<>-1) then
  begin
        CalcDrawInfo(DrawInfo);
        NewSize := ResizeLine(DrawInfo.Horz);
        if (NewSize > 1) then
        begin
        end;
        FSizingPos := X + FSizingOfs;
  end;
  inherited MouseMove(Shift, X, Y);
end;

procedure TwwDBGrid.ClearControls;
begin
   wwClearControls(self);
   RefreshDisplay;
end;

procedure TwwDBGrid.RestoreDesignSelected;
begin
   Selected.assign(OrigSelected);
   ApplySelected;
end;

procedure TwwDBGrid.ShowCurrentControl;
var tc: TWinControl;
begin
   if Focused and (not SuppressShowEditor) and
      (not isMemoField(col, row)) and {11/25/96 - Memo fields should never show editor }
      (dgAlwaysShowEditor in Options) and (not isWWControl(col, row)) then
   begin
      CurrentCustomEdit:=nil;
      if (InplaceEditor<>nil) and InplaceEditor.Focused then
         InplaceEditor.Update
      else begin
         ShowEditor;
      end
   end
   else begin
       // Otherwise not painted with selection in some cases
       //  i.e. richedit first column and then tab
       if (CurrentCustomEdit=nil) and (InplaceEditor<>nil) and
          InplaceEditor.focused then
          InplaceEditor.Update
       else if (CurrentCustomEdit<>nil) and FFocused then begin
           if not CurrentCustomEdit.visible then
           begin
             if MakeCustomControlVisible then
             begin
                CurrentCustomEdit.visible:= true;
             end
             else begin
                CurrentCustomEdit.left:= Width+10;
                CurrentCustomEdit.visible:=true;
             end;
             TEdit(CurrentCustomEdit).modified:= false;
           end;

//           if (dgAlwaysShowEditor in Options) and
           // 3/11/01- Child Inspector seems to require refresh call so
           // code changed to always call refresh.  If find problems
           // then should check specifically for inspector.
           if MakeCustomControlVisible then begin
              if (dgAlwaysShowEditor in Options) then
              begin
                 if not IsDropDownGridShowing then
                 begin
                     // 7/18/01 - if datainspector child edit control then don't reset focus
                     // 8/2/01 - Fix problem with custom controls not respectiing alwaysshoweditor
                     if wwIsClass(currentCustomEdit.classType, 'TwwDataInspector') then
                     begin
                        tc:= screen.activecontrol;
                        if (tc=nil) or (tc.parent<>currentcustomedit) then
                           currentCustomEdit.setFocus;
                     end
                     else begin
                        // 8/22/01 - Don't set focus if active form is not for this grid
                        // For instance, in case there was validation in the tfield.onvalidate event
                        // which showed a message
                        // 5/16/02 - Add test to see if the grid is the activecontrol before setting focus.
//                        if (screen.activeform=getparentform(self)) then
                        if (screen.activeform=getparentform(self)) and IsActiveControl then
                           currentCustomEdit.setFocus;
                     end

                 end
              end;
              currentCustomEdit.refresh;
           end;

           HideEditor;
      end;
   end;
end;

procedure TwwDBGrid.WMPaint(var Message: TWMPaint);
begin
   inherited;
   ShowCurrentControl;
end;

initialization
{  RegisterClass(TwwIButton);}
end.
